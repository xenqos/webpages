<!doctype html>
<html lang="en">
<head>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=1.0'>
  <title>Bitcoin Learning</title>
  <link rel='stylesheet' type='text/css' media='screen' href='/styles/commons.css'>
  <link rel="stylesheet" type="text/css" href="../styles/tipped.css">
  <link rel="stylesheet" type="text/css" href="../styles/jquery-ui.min.css">
  <link rel="stylesheet" type="text/css" href="../styles/tachyons.min.css">
  <link rel="stylesheet" type="text/css" href="../styles/style.css">
  <script type='text/javascript' src='/scripts/commons.js'></script>
</head>
<body>
<div id='idPanel'>
<div id='idTopbar'>
  <div id='idTopbarNavigation'>
    <a href='/'><span class='clNavHome'><span></a>
    <a href='../../index.html'><span class='clNavIndex'><span></a>
    <a href='./57.html'><span class='clNavLeft'><span></a>
    <a href='../index.html'><span class='clNavUp'><span></a>
    <a href='./59.html'><span class='clNavRight'><span></a>
  </div>
</div>

<div id='idContent'>

<h1>58.ECDSA</h1>
<p class="subheading">Elliptic Curve Digital Signature Algorithm</p>

<p><a target='_blank' href='../images/58.ecdsa-bitcoin.png'><img class='clImageThumb' src='../images/58.ecdsa-bitcoin.png'></a><br><br></p>
<p>Bitcoin uses a digital signature system called <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr> to control the ownership of bitcoins.</p>
<p>In short, a digital signature system allows you to generate your own <code class="privatekey">private</code>/<code class="publickey">public</code> key pair, and use the <code class="privatekey">private key</code> to generate <code class="signature">digital signatures</code> that proves you are the owner of the <code class="publickey">public key</code> without having to reveal the <code class="privatekey">private key</code>.</p>
<p>This system is used in Bitcoin to allow people to receive and send bitcoins. Anyone can generate their own pair of keys, and then anyone can send (or “lock”) bitcoins to your <code class="publickey">public key</code>. Nobody can steal these bitcoins, because only the person with the correct <code class="privatekey">private key</code> for this <code class="publickey">public key</code> is able to generate valid signatures to “unlock” the bitcoins and send them to someone else.</p>
<p>The ability to create digital signatures has been around since the 1970s thanks to the invention of RSA. In 1994, DSA was released as the standard for digital signature systems. ECDSA is just an implementation of DSA using <em>elliptic curve</em> cryptography, as the mathematics of elliptic curves allow for more efficient signature creation and verification.</p>
<p>I don’t know enough about cryptography to explain <em>why</em> ECDSA works, but I made this page to show you <em>how</em> you can create your own private and public keys in Bitcoin, and use them to sign your own transactions.</p>
<p>The code is in <strong>Ruby</strong>, and I’ve made the diagrams and equations as simple as I can.</p>
<p class="note text">It wasn’t necessary for Satoshi Nakamoto to know the details of how digital signature systems work either. All they needed to know is that it <em>does</em> work, and that they could use it as the mechanism for sending and receiving money in the system they were building. The first version of Bitcoin used the OpenSSL library to provide the functionality for creating and verifying digital signatures.</p>
<details>
<summary>
Full ECDSA Code (Ruby)
</summary>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span>require <span class="st">&quot;digest&quot;</span> <span class="co"># for hashing transaction data so we can sign it</span></span>
<span>require <span class="st">&quot;securerandom&quot;</span> <span class="co"># for generating random nonces when signing</span></span>
<span></span>
<span><span class="co"># -------------------------</span></span>
<span><span class="co"># Elliptic Curve Parameters</span></span>
<span><span class="co"># -------------------------</span></span>
<span><span class="co"># y² = x³ + ax + b</span></span>
<span><span class="dt">$a</span> = <span class="dv">0</span></span>
<span><span class="dt">$b</span> = <span class="dv">7</span></span>
<span></span>
<span><span class="co"># prime field</span></span>
<span><span class="dt">$p</span> = <span class="dv">2</span> ** <span class="dv">256</span> - <span class="dv">2</span> ** <span class="dv">32</span> - <span class="dv">2</span> ** <span class="dv">9</span> - <span class="dv">2</span> ** <span class="dv">8</span> - <span class="dv">2</span> ** <span class="dv">7</span> - <span class="dv">2</span> ** <span class="dv">6</span> - <span class="dv">2</span> ** <span class="dv">4</span> - <span class="dv">1</span></span>
<span></span>
<span><span class="co"># number of points on the curve we can hit (&quot;order&quot;)</span></span>
<span><span class="dt">$n</span> = <span class="dv">115792089237316195423570985008687907852837564279074904382605163141518161494337</span></span>
<span></span>
<span><span class="co"># generator point (the starting point on the curve used for all calculations)</span></span>
<span><span class="dt">$G</span> = {</span>
<span>  <span class="st">x: </span><span class="dv">55066263022277343669578718895168534326250603453777594175500187360389116729240</span>,</span>
<span>  <span class="st">y: </span><span class="dv">32670510020758816978083085130507043184471273380659243275938904335757337482424</span>,</span>
<span>}</span>
<span></span>
<span><span class="co"># ---------------</span></span>
<span><span class="co"># Modular Inverse: Ruby doesn&#39;t have a built-in modinv function</span></span>
<span><span class="co"># ---------------</span></span>
<span><span class="kw">def</span> inverse(a, m = <span class="dt">$p</span>)</span>
<span>  m_orig = m         <span class="co"># store original modulus</span></span>
<span>  a = a % m <span class="kw">if</span> a &lt; <span class="dv">0</span> <span class="co"># make sure a is positive</span></span>
<span>  prevy, y = <span class="dv">0</span>, <span class="dv">1</span></span>
<span>  <span class="kw">while</span> a &gt; <span class="dv">1</span></span>
<span>    q = m / a</span>
<span>    y, prevy = prevy - q * y, y</span>
<span>    a, m = m % a, a</span>
<span>  <span class="kw">end</span></span>
<span>  <span class="kw">return</span> y % m_orig</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># ------</span></span>
<span><span class="co"># Double: add a point to itself</span></span>
<span><span class="co"># ------</span></span>
<span><span class="kw">def</span> double(point)</span>
<span>  <span class="co"># slope = (3x₁² + a) / 2y₁</span></span>
<span>  slope = ((<span class="dv">3</span> * point[<span class="st">:x</span>] ** <span class="dv">2</span> + <span class="dt">$a</span>) * inverse((<span class="dv">2</span> * point[<span class="st">:y</span>]), <span class="dt">$p</span>)) % <span class="dt">$p</span> <span class="co"># using inverse to help with division</span></span>
<span></span>
<span>  <span class="co"># x = slope² - 2x₁</span></span>
<span>  x = (slope ** <span class="dv">2</span> - (<span class="dv">2</span> * point[<span class="st">:x</span>])) % <span class="dt">$p</span></span>
<span></span>
<span>  <span class="co"># y = slope * (x₁ - x) - y₁</span></span>
<span>  y = (slope * (point[<span class="st">:x</span>] - x) - point[<span class="st">:y</span>]) % <span class="dt">$p</span></span>
<span></span>
<span>  <span class="co"># Return the new point</span></span>
<span>  <span class="kw">return</span> { <span class="st">x: </span>x, <span class="st">y: </span>y }</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># ---</span></span>
<span><span class="co"># Add: add two points together</span></span>
<span><span class="co"># ---</span></span>
<span><span class="kw">def</span> add(point1, point2)</span>
<span>  <span class="co"># double if both points are the same</span></span>
<span>  <span class="kw">if</span> point1 == point2</span>
<span>    <span class="kw">return</span> double(point1)</span>
<span>  <span class="kw">end</span></span>
<span></span>
<span>  <span class="co"># slope = (y₁ - y₂) / (x₁ - x₂)</span></span>
<span>  slope = ((point1[<span class="st">:y</span>] - point2[<span class="st">:y</span>]) * inverse(point1[<span class="st">:x</span>] - point2[<span class="st">:x</span>], <span class="dt">$p</span>)) % <span class="dt">$p</span></span>
<span></span>
<span>  <span class="co"># x = slope² - x₁ - x₂</span></span>
<span>  x = (slope ** <span class="dv">2</span> - point1[<span class="st">:x</span>] - point2[<span class="st">:x</span>]) % <span class="dt">$p</span></span>
<span></span>
<span>  <span class="co"># y = slope * (x₁ - x) - y₁</span></span>
<span>  y = ((slope * (point1[<span class="st">:x</span>] - x)) - point1[<span class="st">:y</span>]) % <span class="dt">$p</span></span>
<span></span>
<span>  <span class="co"># Return the new point</span></span>
<span>  <span class="kw">return</span> { <span class="st">x: </span>x, <span class="st">y: </span>y }</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># --------</span></span>
<span><span class="co"># Multiply: use double and add operations to quickly multiply a point by an integer value (i.e. a private key)</span></span>
<span><span class="co"># --------</span></span>
<span><span class="kw">def</span> multiply(k, point = <span class="dt">$G</span>)</span>
<span>  <span class="co"># create a copy the initial starting point (for use in addition later on)</span></span>
<span>  current = point</span>
<span></span>
<span>  <span class="co"># convert integer to binary representation</span></span>
<span>  binary = k.to_s(<span class="dv">2</span>)</span>
<span></span>
<span>  <span class="co"># double and add algorithm for fast multiplication</span></span>
<span>  binary.split(<span class="st">&quot;&quot;</span>).drop(<span class="dv">1</span>).each <span class="kw">do</span> |char| <span class="co"># from left to right, ignoring first binary character</span></span>
<span>    <span class="co"># 0 = double</span></span>
<span>    current = double(current)</span>
<span></span>
<span>    <span class="co"># 1 = double and add</span></span>
<span>    current = add(current, point) <span class="kw">if</span> char == <span class="st">&quot;1&quot;</span></span>
<span>  <span class="kw">end</span></span>
<span></span>
<span>  <span class="co"># return the final point</span></span>
<span>  current</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># ----</span></span>
<span><span class="co"># Sign</span></span>
<span><span class="co"># ----</span></span>
<span><span class="kw">def</span> sign(private_key, hash, nonce = <span class="dv">nil</span>)</span>
<span>  <span class="co"># generate random number if not given</span></span>
<span>  <span class="kw">if</span> nonce == <span class="dv">nil</span></span>
<span>    loop <span class="kw">do</span></span>
<span>      nonce = <span class="dt">SecureRandom</span>.hex(<span class="dv">32</span>).to_i(<span class="dv">16</span>)</span>
<span>      <span class="kw">break</span> <span class="kw">if</span> nonce &lt; <span class="dt">$n</span> <span class="co"># make sure random numer is below the number of points of the curve</span></span>
<span>    <span class="kw">end</span></span>
<span>  <span class="kw">end</span></span>
<span></span>
<span>  <span class="co"># r = the x value of a random point on the curve</span></span>
<span>  r = multiply(nonce)[<span class="st">:x</span>] % <span class="dt">$n</span></span>
<span></span>
<span>  <span class="co"># s = nonce⁻¹ * (hash + private_key * r) mod n</span></span>
<span>  s = (inverse(nonce, <span class="dt">$n</span>) * (hash + private_key * r)) % <span class="dt">$n</span> <span class="co"># this breaks linearity (compared to schnorr)</span></span>
<span></span>
<span>  <span class="co"># signature is [r, s]</span></span>
<span>  <span class="kw">return</span> { <span class="st">r: </span>r, <span class="st">s: </span>s }</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># ------</span></span>
<span><span class="co"># Verify</span></span>
<span><span class="co"># ------</span></span>
<span><span class="kw">def</span> verify(public_key, signature, hash)</span>
<span>  <span class="co"># point 1</span></span>
<span>  point1 = multiply(inverse(signature[<span class="st">:s</span>], <span class="dt">$n</span>) * hash)</span>
<span></span>
<span>  <span class="co"># point 2</span></span>
<span>  point2 = multiply((inverse(signature[<span class="st">:s</span>], <span class="dt">$n</span>) * signature[<span class="st">:r</span>]), public_key)</span>
<span></span>
<span>  <span class="co"># add two points together</span></span>
<span>  point3 = add(point1, point2)</span>
<span></span>
<span>  <span class="co"># check x coordinate of this point matches the x-coordinate of the random point given</span></span>
<span>  <span class="kw">return</span> point3[<span class="st">:x</span>] == signature[<span class="st">:r</span>]</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># -------------------</span></span>
<span><span class="co"># Create A Public Key</span></span>
<span><span class="co"># -------------------</span></span>
<span><span class="co"># Example private key (in hexadecimal)</span></span>
<span>private_key = <span class="st">&quot;f94a840f1e1a901843a75dd07ffcc5c84478dc4f987797474c9393ac53ab55e6&quot;</span></span>
<span></span>
<span><span class="co"># Public key is the generator point multiplied by the private key</span></span>
<span>point = multiply(private_key.to_i(<span class="dv">16</span>))</span>
<span></span>
<span><span class="co"># convert x and y values of the public key point to hexadecimal</span></span>
<span>x = point[<span class="st">:x</span>].to_s(<span class="dv">16</span>).rjust(<span class="dv">64</span>, <span class="st">&quot;0&quot;</span>) <span class="co"># pad with zeros to make sure it&#39;s 64 characters (32 bytes)</span></span>
<span>y = point[<span class="st">:y</span>].to_s(<span class="dv">16</span>).rjust(<span class="dv">64</span>, <span class="st">&quot;0&quot;</span>)</span>
<span></span>
<span><span class="co"># uncompressed public key (use full x and y coordinates) OLD FORMAT!</span></span>
<span>public_key_uncompressed = <span class="st">&quot;04&quot;</span> + x + y</span>
<span></span>
<span><span class="co"># compressed public key (use a prefix to indicate whether y is even or odd)</span></span>
<span><span class="kw">if</span> (point[<span class="st">:y</span>] % <span class="dv">2</span> == <span class="dv">0</span>)</span>
<span>  public_key_compressed = <span class="st">&quot;02&quot;</span> + x <span class="co"># y is even</span></span>
<span><span class="kw">else</span></span>
<span>  public_key_compressed = <span class="st">&quot;03&quot;</span> + x <span class="co"># y is odd</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co">#puts public_key_compressed #=&gt; 024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1</span></span>
<span></span>
<span><span class="co"># ------------------</span></span>
<span><span class="co"># Sign A Transaction</span></span>
<span><span class="co"># ------------------</span></span>
<span><span class="co"># A basic structure for holding the transaction data</span></span>
<span><span class="kw">def</span> tx(scriptsig)</span>
<span>  <span class="co"># Need to calculate a byte indicating the size of upcoming scriptsig in bytes (rough code but does the job)</span></span>
<span>  size = (scriptsig.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>)</span>
<span></span>
<span>  <span class="co"># Raw unsigned transaction data with the scriptsig field (you need to know the correct position)</span></span>
<span>  <span class="kw">return</span> <span class="st">&quot;0100000001b7994a0db2f373a29227e1d90da883c6ce1cb0dd2d6812e4558041ebbbcfa54b00000000</span><span class="ot">#{</span>size<span class="ot">}#{</span>scriptsig<span class="ot">}</span><span class="st">ffffffff01983a0000000000001976a914b3e2819b6262e0b1f19fc7229d75677f347c91ac88ac00000000&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># Private key and public key for the locked up bitcoins we want to spend</span></span>
<span>private_key = <span class="st">&quot;f94a840f1e1a901843a75dd07ffcc5c84478dc4f987797474c9393ac53ab55e6&quot;</span> <span class="co"># sha256(&quot;learnmeabitcoin1&quot;)</span></span>
<span>public_key = <span class="st">&quot;024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1&quot;</span></span>
<span></span>
<span><span class="co"># </span><span class="al">NOTE</span><span class="co">: Need to remove all existing signatures from the transaction data first if there are any</span></span>
<span></span>
<span><span class="co"># Put original scriptpubkey as a placeholder in to the scriptsig for the input you want to sign (required)</span></span>
<span>scriptpubkey = <span class="st">&quot;76a9144299ff317fcd12ef19047df66d72454691797bfc88ac&quot;</span> <span class="co"># just one input in this transaction</span></span>
<span>transaction = tx(scriptpubkey)</span>
<span></span>
<span><span class="co"># Append sighash type to transaction data (required)</span></span>
<span>transaction = transaction + <span class="st">&quot;01000000&quot;</span></span>
<span></span>
<span><span class="co"># Get a hash of the transaction data (because we sign the hash of data and not the actual data itself)</span></span>
<span>hash = <span class="dt">Digest</span>::<span class="dt">SHA256</span>.hexdigest(<span class="dt">Digest</span>::<span class="dt">SHA256</span>.digest([transaction].pack(<span class="st">&quot;H*&quot;</span>)))</span>
<span></span>
<span><span class="co"># Use elliptic curve mathematics to sign the hash using the private key and nonce</span></span>
<span>signature = sign(private_key.to_i(<span class="dv">16</span>), hash.to_i(<span class="dv">16</span>), <span class="dv">123456789</span>) <span class="co"># using a fixed nonce for testing (unsafe)</span></span>
<span></span>
<span><span class="co"># Use the low s value (BIP 62: Dealing with malleability)</span></span>
<span><span class="kw">if</span> (signature[<span class="st">:s</span>] &gt; <span class="dt">$n</span> / <span class="dv">2</span>)</span>
<span>  signature[<span class="st">:s</span>] = <span class="dt">$n</span> - signature[<span class="st">:s</span>]</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># Encode the signature in to DER format (slightly awkward format used for signatures in bitcoin transactions)</span></span>
<span>r = signature[<span class="st">:r</span>].to_s(<span class="dv">16</span>).rjust(<span class="dv">64</span>, <span class="st">&quot;0&quot;</span>)  <span class="co"># convert r to hexadecimal</span></span>
<span>s = signature[<span class="st">:s</span>].to_s(<span class="dv">16</span>).rjust(<span class="dv">64</span>, <span class="st">&quot;0&quot;</span>)  <span class="co"># convert s to hexadecimal</span></span>
<span>r = <span class="st">&quot;00&quot;</span> + r <span class="kw">if</span> (r[<span class="dv">0</span>, <span class="dv">2</span>].to_i(<span class="dv">16</span>) &gt;= <span class="bn">0x80</span>) <span class="co"># prepend 00 if first byte is 0x80 or above (DER quirk)</span></span>
<span>s = <span class="st">&quot;00&quot;</span> + r <span class="kw">if</span> (s[<span class="dv">0</span>, <span class="dv">2</span>].to_i(<span class="dv">16</span>) &gt;= <span class="bn">0x80</span>) <span class="co"># prepend 00 if first byte is 0x80 or above (DER quirk)</span></span>
<span>der = <span class="st">&quot;&quot;</span>                                   <span class="co"># string for holding our der encoding</span></span>
<span>r_len = (r.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>) <span class="co"># get length of r (in bytes)</span></span>
<span></span>
<span>s_len = (s.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>) <span class="co"># get length of s (in bytes)</span></span>
<span>der &lt;&lt; <span class="st">&quot;02&quot;</span> &lt;&lt; r_len &lt;&lt; r &lt;&lt; <span class="st">&quot;02&quot;</span> &lt;&lt; s_len &lt;&lt; s   <span class="co"># Add to DER encoding (0x20 byte indicates an integer type in DER)</span></span>
<span>der_len = (der.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>) <span class="co"># get length of DER data (in bytes)</span></span>
<span>der = <span class="st">&quot;30&quot;</span> + der_len + der <span class="co"># Final DER encoding (0x30 byte incatetes compound object type)</span></span>
<span></span>
<span><span class="co"># Append sighashtype to the signature (required) (01 = ALL)</span></span>
<span>der = der + <span class="st">&quot;01&quot;</span> <span class="co"># without it you get &quot;mandatory-script-verify-flag-failed (Non-canonical DER signature) (code 16)&quot;</span></span>
<span></span>
<span><span class="co"># Contruct full unlocking script (P2PKH scripts need original public key the bitcoins were locked to): &lt;size&gt; {signature} &lt;size&gt; {public_key}</span></span>
<span>scriptsig = (der.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>) + der + (public_key.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>) + public_key</span>
<span></span>
<span><span class="co"># Put the full scriptsig in to the original transaction data</span></span>
<span>transaction = tx(scriptsig)</span>
<span></span>
<span><span class="co"># Show the signed transaction</span></span>
<span>puts transaction <span class="co">#=&gt; 0100000001b7994a0db2f373a29227e1d90da883c6ce1cb0dd2d6812e4558041ebbbcfa54b000000006a473044022008f4f37e2d8f74e18c1b8fde2374d5f28402fb8ab7fd1cc5b786aa40851a70cb02201f40afd1627798ee8529095ca4b205498032315240ac322c9d8ff0f205a93a580121024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1ffffffff01983a0000000000001976a914b3e2819b6262e0b1f19fc7229d75677f347c91ac88ac00000000</span></span>
<span></span>
<span><span class="co"># Send the transaction in to the bitcoin network</span></span>
<span><span class="co"># $ bitcoin-cli sendrawtransaction [raw transaction data]</span></span></code></pre></div>
</details>

<h2>Elliptic Curves</h2>
<p><a target='_blank' href='../images/58.latex-elliptic-curve-equation.png'><img class='clImageThumb' src='../images/58.latex-elliptic-curve-equation.png'></a><br><br></p>

<a target='_blank' href='../images/58.elliptic-curve.png'><img class='clImageThumb' src='../images/58.elliptic-curve.png'></a><br><br>
<p class='clFigcaption'>An elliptic curve.</p>


<p>ECDSA uses an elliptic curve as the basis for a digital signature system.</p>
<p>In summary, <code class="publickey">public keys</code> and <code class="signature">signatures</code> are just <strong>points</strong> on an elliptic curve. If both of these points are created from the same <code class="privatekey">private key</code> (a large number), there will be a <em>geometric connection</em> between them that proves that the person who created the <code class="signature">signature</code> also created (or “owns”) the <code class="publickey">public key</code> too.</p>
<h3>Parameters</h3>
<p>There are a number of different curves that can be used in ECDSA. Satoshi chose the <em>secp256k1</em> curve, which has the following parameters:</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="co"># y² = x³ + ax + b</span></span>
<span><span class="dt">$a</span> = <span class="dv">0</span></span>
<span><span class="dt">$b</span> = <span class="dv">7</span></span>
<span></span>
<span><span class="co"># prime field</span></span>
<span><span class="dt">$p</span> = <span class="dv">2</span> ** <span class="dv">256</span> - <span class="dv">2</span> ** <span class="dv">32</span> - <span class="dv">2</span> ** <span class="dv">9</span> - <span class="dv">2</span> ** <span class="dv">8</span> - <span class="dv">2</span> ** <span class="dv">7</span> - <span class="dv">2</span> ** <span class="dv">6</span> - <span class="dv">2</span> ** <span class="dv">4</span> - <span class="dv">1</span></span>
<span></span>
<span><span class="co"># number of points on the curve we can hit (&quot;order&quot;)</span></span>
<span><span class="dt">$n</span> = <span class="dv">115792089237316195423570985008687907852837564279074904382605163141518161494337</span></span>
<span></span>
<span><span class="co"># generator point (the starting point on the curve used for all calculations)</span></span>
<span><span class="dt">$G</span> = {</span>
<span>  <span class="st">x: </span><span class="dv">55066263022277343669578718895168534326250603453777594175500187360389116729240</span>,</span>
<span>  <span class="st">y: </span><span class="dv">32670510020758816978083085130507043184471273380659243275938904335757337482424</span>,</span>
<span>}</span></code></pre></div>
<ul>
<li>An elliptic curve is a set of points described by the <strong>equation</strong> <code>y² = x³ + ax + b</code>, so this is where the <code>a</code> and <code>b</code> variables come from. Different curves will have different values for these coefficients, and <code>a=0</code> and <code>b=7</code> are the ones specific to <em>secp256k1</em>.</li>
<li>The <strong>prime modulus</strong> <code>p</code> is just a number that keeps all of the numbers within a specific range when performing mathematical calculations (again it’s specific to <em>secp256k1</em>). The fact that it’s a prime number is a key ingredient for the cryptography to work, but that’s an aside.</li>
<li>There are <code>n</code> <strong>number of points on the curve we can reach</strong>. This is also referred to as the “order”. It’s less than <code>p</code>, and it’s based on the chosen generator point (see below).</li>
<li>Finally, every curve has a <strong>generator point</strong> <code>G</code>, which is basically the <em>starting point</em> on the curve used when performing most mathematical operations. The exact origin for the choice of this point is unknown<sup>1</sup>, but it’s usually because it provides a high <em>order</em> (see above) and has shown to not have any inherent cryptographic weaknesses.</li>
</ul>

<a target='_blank' href='../images/58.point-generator.png'><img class='clImageThumb' src='../images/58.point-generator.png'></a><br><br>
<p class='clFigcaption'>Every curve has a generator point <code>G</code>.</p>


<details>
<summary>
<strong>Note:</strong> Elliptic curves over a finite field.
</summary>
<p>The diagrams I’m using in this tutorial show a smooth elliptic curve like this:</p>

<a target='_blank' href='../images/58.sage-elliptic-curve-real-numbers.png'><img class='clImageThumb' src='../images/58.sage-elliptic-curve-real-numbers.png'></a><br><br>
<p class='clFigcaption'>Elliptic curve over <em>real numbers</em> (showing example point at <code>x=1.123, y=2.90107701845366</code>)</p>


<p>However, the actual curve used in Bitcoin looks more like a scatter plot of points like this:</p>

<a target='_blank' href='../images/58.sage-elliptic-curve-finite-field-47.png'><img class='clImageThumb' src='../images/58.sage-elliptic-curve-finite-field-47.png'></a><br><br>
<p class='clFigcaption'>Elliptic curve over a <em>finite field</em> <code>mod 47</code> (showing example point at <code>x=17, y=19</code>)</p>


<p>This is due to the fact that the curve used in Bitcoin is over a <em>finite field</em> of <em>whole numbers</em> (i.e. using <code>mod p</code> to restrict numbers to within a certain range), and this breaks the continuous curve you’re able to get when you use <em>real numbers</em>. However, even though these plots look wildly different, <strong>the mathematical operations you can perform on both of these curves will still work in the same way</strong>.</p>
<p>Of course, the <em>secp256k1</em> curve has a <em>very large</em> value for <code>p</code>, so it more closely resembles a graph that looks like the following, except imagine there are about as many points on it as there are atoms in the universe:</p>

<a target='_blank' href='../images/58.sage-elliptic-curve-finite-field-2503.png'><img class='clImageThumb' src='../images/58.sage-elliptic-curve-finite-field-2503.png'></a><br><br>
<p class='clFigcaption'>Elliptic curve over a <em>finite field</em> <code>mod 2503</code></p>


<p>But why use finite fields?</p>
<p>Because, when implementing cryptography on computers, it’s easier to work with the whole numbers in a <em>finite</em> field (e.g. <code>1, 2, 3, 4, ..., p</code>), than it is to work with an <em>infinite</em> amount of the real numbers (e.g. <code>0.911722707844879, 2.90107701845366, ...</code>). You risk losing accuracy when working with all these decimal numbers on a computer, so the precision you get with a finite set of whole numbers is better suited for cryptography.</p>
For the rest of this tutorial I’ll be showing the smooth curve because it looks better for illustrative purposes.
</details>
<details>
<summary>
<strong>Note:</strong> Why is it called <em>secp256k1</em>?
</summary>
<p>This is a nickname for one of the specific curves used in elliptic curve cryptography:</p>
<ul>
<li><em>sec</em> = Standard for Efficient Cryptography — A consortium that develops commercial standards for cryptography.</li>
<li><em>p</em> = Prime — The prime number used to create the finite field.</li>
<li><em>256</em> = 256 bits — Size of the prime field used.</li>
<li><em>k</em> = Koblitz — Specific type of curve.</li>
<li><em>1</em> = First curve in this category.</li>
</ul>
</details>
<h2>Elliptic Curve Mathematics</h2>
<p>There are a few mathematical operations that you can perform on <em>points</em> on the elliptic curve. The main two operations are <code>double()</code> and <code>add()</code>, and these can then be combined to perform <code>multiply()</code>.</p>
<p>These operations are the building blocks of elliptic curve cryptography, and they are used for generating <code class="publickey">public keys</code> and <code class="signature">signatures</code> in ECDSA.</p>
<ul>
<li>Modular Inverse</li>
<li>Double</li>
<li>Add</li>
<li>Multiply</li>
</ul>
<h3>Modular Inverse</h3>
<p>Before being able to perform <code>double()</code> and <code>add()</code> operations on points on the curve, we first need to be able to find the <em>modular inverse</em> of a number in a finite field (bare with me).</p>
<p>You see, there is no actual straightforward “division” operation in elliptic curve cryptography because all of the mathematics takes place within a <span class="tooltip" data-tooltip="A ring of integers with a finite number of elements.">finite field</span> of numbers.</p>
<p>However, in a finite field you <em>can</em> <strong>multiply by the <em>inverse</em></strong> of a number to achieve the same result as <strong>division</strong>.</p>

<a target='_blank' href='../images/58.modular-inverse.gif'><img class='clImageThumb' src='../images/58.modular-inverse.gif'></a><br><br>
<p class='clFigcaption'><strong><code>29</code></strong> is the modular multiplicative inverse of <code>13</code> in the finite field of <code>47</code>.</p>


<p>In other words, if you start at a specific number in a finite field and multiply by another number, you can “go backwards” to the number you started with by multiplying again by the <em>inverse</em> of the number you used for multiplication.</p>
<p class="note tip"><strong>This always works when you have a <em>prime</em> number of elements in the field.</strong> A prime number cannot be divided by any other number, so it will distribute the results from modular multiplication back across each of the numbers in the field evenly (without repeating and missing some numbers). So by using a prime number as the modulus you can guarantee that each number in the finite field will have a multiplicative inverse (or a “division” operation).</p>
<p>Obviously this is a confusing first step in to elliptic curve math, but just think of “finding the inverse” as a basic tool in modular arithmetic.</p>
<p>Not all programming languages have a built-in “modular inverse” function though, which is why you sometimes have to implement one yourself to get started with elliptic curve mathematics, such as in Ruby:</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="kw">def</span> inverse(a, m = <span class="dt">$p</span>)</span>
<span>  m_orig = m         <span class="co"># store original modulus</span></span>
<span>  a = a % m <span class="kw">if</span> a &lt; <span class="dv">0</span> <span class="co"># make sure a is positive</span></span>
<span>  prevy, y = <span class="dv">0</span>, <span class="dv">1</span></span>
<span>  <span class="kw">while</span> a &gt; <span class="dv">1</span></span>
<span>    q = m / a</span>
<span>    y, prevy = prevy - q * y, y</span>
<span>    a, m = m % a, a</span>
<span>  <span class="kw">end</span></span>
<span>  <span class="kw">return</span> y % m_orig</span>
<span><span class="kw">end</span></span></code></pre></div>
<p class="note text">This function uses the extended Euclidean algorithm (you don’t need to know how it works) to find the modular inverse of a number. It’s just a quicker method than trying to find the inverse via brute-force.</p>
<p class="note text">The upcoming <code>double()</code> and <code>add()</code> equations include <em>division</em> <code>/</code>, which is why we need to be able to work out the modular inverse of a number (in a prime field) before moving forward.</p>
<div class="note text">
<p>The modular inverse of a number is typically denoted by <code>⁻¹</code> in mathematical equations.</p>
<p><a target='_blank' href='../images/58.inverse-notation.png'><img class='clImageThumb' src='../images/58.inverse-notation.png'></a><br><br></p>
<p>In the upcoming mathematics, the inverse of a number is sometimes found <code>mod p</code> (modulo the <em>prime</em>), and is sometimes found <code>mod n</code> (modulo the <em>number of points</em> on the curve). It depends on which modulus is being used for the equation.</p>
</div>
<h3>Double</h3>
<p>“Doubling” a point is the same thing as “adding” a point to itself.</p>
<p>From a visual perspective, to “double” a point you draw a <em>tangent</em> to the curve at the given point, then find the point on the curve this line intersects (there will only be one), then take the reflection of this point across the x-axis.</p>

<a target='_blank' href='../images/58.point-double.png'><img class='clImageThumb' src='../images/58.point-double.png'></a><br><br>
<p class='clFigcaption'><code>P</code> is just the letter used for a general point on the curve.<br><code>s</code> here refers to the slope of the tangent.</p>



<a target='_blank' href='../images/58.latex-point-double.png'><img class='clImageThumb' src='../images/58.latex-point-double.png'></a><br><br>
<p class='clFigcaption'>Elliptic curve point doubling.</p>


<div class="note text">
<p><strong>Elliptic Curve Operations.</strong></p>
<p>As you can see, you’re not actually “doubling” the values of the <code>x, y</code> coordinates of a point here (like you would do in everyday arithmetic). The “double”, “add”, and “multiply” terms on this page refer to specific operations we perform with <em>points</em> on <em>elliptic curves</em>. So even though they have the same names as normal mathematical operations, understand that they are completely different when in the domain of elliptic curve mathematics.</p>
<p>This can get a bit confusing at times because there are also everyday “add” and “multiply” operations in amongst these equations too. The trick is to remember that every time one of these operations is on a <em>point</em>, we’re using the <em>elliptic curve operations</em>. And when these operations are on two integers, it’s just everyday arithmetic.</p>
</div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="kw">def</span> double(point)</span>
<span>  <span class="co"># slope = (3x₁² + a) / 2y₁</span></span>
<span>  slope = ((<span class="dv">3</span> * point[<span class="st">:x</span>] ** <span class="dv">2</span> + <span class="dt">$a</span>) * inverse((<span class="dv">2</span> * point[<span class="st">:y</span>]), <span class="dt">$p</span>)) % <span class="dt">$p</span> <span class="co"># using inverse to help with division</span></span>
<span></span>
<span>  <span class="co"># x = slope² - 2x₁</span></span>
<span>  x = (slope ** <span class="dv">2</span> - (<span class="dv">2</span> * point[<span class="st">:x</span>])) % <span class="dt">$p</span></span>
<span></span>
<span>  <span class="co"># y = slope * (x₁ - x) - y₁</span></span>
<span>  y = (slope * (point[<span class="st">:x</span>] - x) - point[<span class="st">:y</span>]) % <span class="dt">$p</span></span>
<span></span>
<span>  <span class="co"># Return the new point</span></span>
<span>  <span class="kw">return</span> { <span class="st">x: </span>x, <span class="st">y: </span>y }</span>
<span><span class="kw">end</span></span></code></pre></div>
<h3>Add</h3>
<p>As expected, “addition” of two points in elliptic curve mathematics isn’t the same as straightforward integer addition, but it’s called “addition” anyway.</p>
<p>From a visual perspective, to “add” two points together you draw a line between them, then find the point on the curve this line intersects (there will only be one), then take the reflection of this point across the x-axis.</p>

<a target='_blank' href='../images/58.point-add.png'><img class='clImageThumb' src='../images/58.point-add.png'></a><br><br>
<p class='clFigcaption'><code>Q</code> is just the letter used for a second general point on the curve.</p>



<a target='_blank' href='../images/58.latex-point-add.png'><img class='clImageThumb' src='../images/58.latex-point-add.png'></a><br><br>
<p class='clFigcaption'>Elliptic curve point addition.</p>


<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="kw">def</span> add(point1, point2)</span>
<span>  <span class="co"># double if both points are the same</span></span>
<span>  <span class="kw">if</span> point1 == point2</span>
<span>    <span class="kw">return</span> double(point1)</span>
<span>  <span class="kw">end</span></span>
<span></span>
<span>  <span class="co"># slope = (y₁ - y₂) / (x₁ - x₂)</span></span>
<span>  slope = ((point1[<span class="st">:y</span>] - point2[<span class="st">:y</span>]) * inverse(point1[<span class="st">:x</span>] - point2[<span class="st">:x</span>], <span class="dt">$p</span>)) % <span class="dt">$p</span></span>
<span></span>
<span>  <span class="co"># x = slope² - x₁ - x₂</span></span>
<span>  x = (slope ** <span class="dv">2</span> - point1[<span class="st">:x</span>] - point2[<span class="st">:x</span>]) % <span class="dt">$p</span></span>
<span></span>
<span>  <span class="co"># y = slope * (x₁ - x) - y₁</span></span>
<span>  y = ((slope * (point1[<span class="st">:x</span>] - x)) - point1[<span class="st">:y</span>]) % <span class="dt">$p</span></span>
<span></span>
<span>  <span class="co"># Return the new point</span></span>
<span>  <span class="kw">return</span> { <span class="st">x: </span>x, <span class="st">y: </span>y }</span>
<span><span class="kw">end</span></span></code></pre></div>
<h3>Multiply</h3>
<p>Now that we can “double” and “add” points on the curve, we can now take any point on the curve and “multiply” it by an integer to get to a completely new point. <strong>This operation is the heart of elliptic curve cryptography.</strong></p>
<p>The simplest method for elliptic curve multiplication would be to repeatedly “add” a point to itself until you reach the number you want to multiply by, which <em>would</em> work to a degree, but these incremental <code>add()</code> operations would make this approach impossibly slow when multiplying by large numbers (like the ones used in Bitcoin).</p>
<p>Thankfully there is a faster way to perform multiplication on elliptic curves…</p>
<h4>Double-and-add algorithm</h4>

<a target='_blank' href='../images/58.point-multiply.gif'><img class='clImageThumb' src='../images/58.point-multiply.gif'></a><br><br>
<p class='clFigcaption'><code>3 * P</code> is the same as one <code>double()</code> operation and one <code>add()</code> operation: <code>3P = 2P + P</code></p>


<p>A faster approach to multiplication is to use the <em>double-and-add algorithm</em>, where you make an efficient use of both <em>doubling</em> and <em>adding</em> to reach the target multiple in <strong>as few operations as possible</strong>.</p>
<p>For example, if you start at <code>2</code> and want to get to <code>128</code>, it’s faster to perfom <em>six</em> <code>double()</code> operations than it is to perform <em>sixty-four</em> <code>add()</code> operations.</p>
<p>But how do you know how many double and add operations you need to get to your target multiple?</p>
<p>Well, amazingly, if you convert any integer in to its <em>binary</em> representation, the <code>1</code>s and <code>0</code>s will provide a map for the sequence of <code>double()</code> and <code>add()</code> operations you need to perform to reach that multiple.</p>
<p>Working from left to right and ignoring the first number:</p>
<ul>
<li><code>0</code> = double</li>
<li><code>1</code> = double and add</li>
</ul>
<p>For example:</p>
<pre><code>e.g. 1 * 21

21 = 10101 (binary)
      │││└ double and add = 21
      ││└─ double         = 10
      │└── double and add = 5
      └─── double         = 2
                            1  &lt;- start here</code></pre>
<p>Anyway, here’s what <strong>elliptic curve multiplication</strong> looks like when <em>using the double-and-add algorithm</em> in Ruby code:</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="kw">def</span> multiply(k, point = <span class="dt">$G</span>)</span>
<span>  <span class="co"># create a copy the initial starting point (for use in addition later on)</span></span>
<span>  current = point</span>
<span></span>
<span>  <span class="co"># convert integer to binary representation</span></span>
<span>  binary = k.to_s(<span class="dv">2</span>)</span>
<span></span>
<span>  <span class="co"># double and add algorithm for fast multiplication</span></span>
<span>  binary.split(<span class="st">&quot;&quot;</span>).drop(<span class="dv">1</span>).each <span class="kw">do</span> |char| <span class="co"># from left to right, ignoring first binary character</span></span>
<span>    <span class="co"># 0 = double</span></span>
<span>    current = double(current)</span>
<span></span>
<span>    <span class="co"># 1 = double and add</span></span>
<span>    current = add(current, point) <span class="kw">if</span> char == <span class="st">&quot;1&quot;</span></span>
<span>  <span class="kw">end</span></span>
<span></span>
<span>  <span class="co"># return the final point</span></span>
<span>  current</span>
<span><span class="kw">end</span></span></code></pre></div>
<p class="note text">Most multiplication operations in ECDSA start at the <strong>generator point</strong> <code>G</code>.</p>
<p class="note text"><strong>Every multiplication operation starts with a <code>double()</code>.</strong> This is because you’re starting with a single point (e.g. the generator point).</p>
<h2>ECDSA</h2>
<p>Now that we know about the structure of elliptic curves and we have a <code>multiply()</code> operation for points, we can actually use this as the basis for a system for creating digital signatures.</p>
<p>The following system is called the <em>Elliptic Curve Digital Signature Algorithm</em>, or ECDSA for short.</p>
<ul>
<li>Key Generation</li>
<li>Sign</li>
<li>Verify</li>
</ul>
<h3>Key Generation</h3>
<p>We create pairs of <strong>keys</strong> using elliptic curve multiplication:</p>
<ul>
<li><code class="privatekey">private key</code> <code>d</code> — A large randomly-generated number between <code>[0...n-1]</code></li>
<li><code class="publickey">public key</code> <code>Q</code> — The <strong>generator point</strong> <code>G</code> multiplied by this random number <code>d</code>.</li>
</ul>

<a target='_blank' href='../images/58.point-multiply-public-key.gif'><img class='clImageThumb' src='../images/58.point-multiply-public-key.gif'></a><br><br>
<p class='clFigcaption'><code>d</code> is the <code class="privatekey">private key</code> (an integer)<br><code>G</code> is the generator point (a point)<br><code>Q</code> is the <code class="publickey">public key</code> (a point)</p>


<p><a target='_blank' href='../images/58.latex-point-multiply.png'><img class='clImageThumb' src='../images/58.latex-point-multiply.png'></a><br><br></p>
<p>So in elliptic curve cryptography, a <code class="privatekey">private key</code> is just a large <strong>random integer</strong> (less than the number of points on the curve), and its corresponding <code class="publickey">public key</code> is just a <strong>point on the curve</strong>.</p>
<p>For example:</p>
<pre class="f6"><code>private key = 112757557418114203588093402336452206775565751179231977388358956335153294300646
public key  = {
    x: 33886286099813419182054595252042348742146950914608322024530631065951421850289,
    y: 9529752953487881233694078263953407116222499632359298014255097182349749987176
}
</code></pre>

<details>
<summary>
<strong>Trapdoor Function:</strong> You can give your <code class="publickey">public key</code> to anyone, and your <code class="privatekey">private key</code> will remain secret.
</summary>
<p><a target='_blank' href='../images/58.point-multiply-public-key-trapdoor.png'><img class='clImageThumb' src='../images/58.point-multiply-public-key-trapdoor.png'></a><br><br></p>
<p>An important point (heh) to note here is that given a <code class="publickey">public key</code> point <code>Q</code>, there’s no easy way to work out the <code class="privatekey">private key</code> <code>d</code> used to create it. The only way to work out the <code class="privatekey">private key</code> would be to manually multiply the generator point <code>G</code> by different numbers to see if you can get the same public key, and this brute-force approach is going to be impossibly slow if someone has used a very large number for their private key.</p>
<p>Therefore elliptic curve multiplication is known as a <em>trapdoor function</em> (because it’s easy to go one way but difficult to go the other), which is a key component of all <em>public key cryptography</em>.</p>
Furthermore, the one-way mathematical connection between the <code class="privatekey">private key</code> and <code class="publickey">public key</code> means that you can use both independently to calculate the same points on the elliptic curve later on, which comes in very handy when constructing a system for creating digital signatures.
</details>
<h3>Sign</h3>
<p>To sign a message you need three things:</p>
<ol type="1">
<li><strong>Random Number</strong> <code>k</code> — This introduces an element of randomness in to our signatures, which is important for security. It means that every signature we generate will be different, even if we sign the same message twice.</li>
<li><strong>Message Hash</strong> <code>z</code> — This is the <em>hash</em> of the message we want to sign. Hashing the message gives us a small and unique fingerprint for it, and it’s more efficient to sign this fingerprint than it is to sign a large blob of data. You have a choice of which hash algorithm to use, but the one most commonly used with <em>secp256k1</em> is <code>SHA-256</code>.</li>
<li><strong><code class="privatekey">Private Key</code></strong> <code>d</code> — The source of a <code class="publickey">public key</code> (that we’ve made publicly available).</li>
</ol>
<p class="mt4">
An actual <code class="signature">signature</code> is then made of two parts:
</p>
<ul>
<li><code>r</code> — <strong>A random point on the curve.</strong> We take the random number <code>k</code> and multiply it by the generator point to get a random point <code>R</code>. We only actually use the <em>x-coordinate</em> of this point, and we call this lowercase <code>r</code>.</li>
<li><code>s</code> — <strong>A number to accompany the random point.</strong> This is a unique number created from a combination of the <em>message hash</em> <code>z</code> and <code class="privatekey">private key</code> <code>d</code>, which is also bound to the random point using <code>r</code>.</li>
</ul>
<p><a target='_blank' href='../images/58.point-sign.gif'><img class='clImageThumb' src='../images/58.point-sign.gif'></a><br><br></p>
<p><a target='_blank' href='../images/58.latex-sign.png'><img class='clImageThumb' src='../images/58.latex-sign.png'></a><br><br></p>
<p class="note text">The <code>⁻¹</code> notation indicates the modular inverse of that number. Here the modular multipicative inverse is found <code>mod n</code> (the number of points on the curve).</p>
<p>These two <code>[r, s]</code> values are the “digital signature”.</p>
<p>For example:</p>
<pre class="f6"><code>random number   (k): 12345
message:             ECDSA is the most fun I have ever experienced
sha256(message) (z): 103318048148376957923607078689899464500752411597387986125144636642406244063093
private key     (d): 112757557418114203588093402336452206775565751179231977388358956335153294300646

random point (k*G = R): {
  x = 108607064596551879580190606910245687803607295064141551927605737287325610911759,
  y = 6661302038839728943522144359728938428925407345457796456954441906546235843221
}
signature: r = R[x], s = k⁻¹ * (z + r * d): {
  r = 108607064596551879580190606910245687803607295064141551927605737287325610911759,
  s = 73791001770378044883749956175832052998232581925633570497458784569540878807131
}
</code></pre>
<p>In short, the unique <code>s</code> value provides a <em>pathway</em> for getting to the randomly-generated point <code>r</code>.</p>
<p>You can give these two pieces of information to someone else, and <strong>starting from the <code class="publickey">public key</code> point <code>Q</code></strong> they can use the <code>s</code> value to help them get to the random point <code>r</code>. The trick here is that only the person with the corresponding <code class="privatekey">private key</code> <code>d</code> could create a valid pathway to this random point provided by <code>s</code>.</p>
<p>This pathway also has the <em>message hash</em> <code>z</code> encoded in to it, which is what effectively allows us to create signatures for messages; nobody can create the pathways from the <code class="publickey">public key</code> to a random point on the curve <strong>via the <em>message hash</em></strong> without knowing the <code class="privatekey">private key</code> it was created from.</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="kw">def</span> sign(private_key, hash, nonce = <span class="dv">nil</span>)</span>
<span>  <span class="co"># generate random number if not given</span></span>
<span>  <span class="kw">if</span> nonce == <span class="dv">nil</span></span>
<span>    loop <span class="kw">do</span></span>
<span>      nonce = <span class="dt">SecureRandom</span>.hex(<span class="dv">32</span>).to_i(<span class="dv">16</span>)</span>
<span>      <span class="kw">break</span> <span class="kw">if</span> nonce &lt; <span class="dt">$n</span> <span class="co"># make sure random numer is below the number of points of the curve</span></span>
<span>    <span class="kw">end</span></span>
<span>  <span class="kw">end</span></span>
<span></span>
<span>  <span class="co"># r = the x value of a random point on the curve</span></span>
<span>  r = multiply(nonce)[<span class="st">:x</span>] % <span class="dt">$n</span></span>
<span></span>
<span>  <span class="co"># s = nonce⁻¹ * (hash + private_key * r) mod n</span></span>
<span>  s = (inverse(nonce, <span class="dt">$n</span>) * (hash + private_key * r)) % <span class="dt">$n</span> <span class="co"># this breaks linearity (compared to schnorr)</span></span>
<span></span>
<span>  <span class="co"># signature is [r, s]</span></span>
<span>  <span class="kw">return</span> { <span class="st">r: </span>r, <span class="st">s: </span>s }</span>
<span><span class="kw">end</span></span></code></pre></div>
<p class="note tip"><strong>Nonce:</strong> A random number in cryptography is sometimes called a “nonce”, which stands for “number used once”.</p>
<details>
<summary>
<strong>Why do you need to generate a random point each time?</strong> (Mathematical Explanation)
</summary>
<p class="mb4 note warning">
If you use the same value for <code>k</code> more than once (i.e. you use the <em>same random point</em> for more than one signature), anyone can actually work out your <code class="privatekey">private key</code> from your signatures.
</p>
<p>For example, lets say we’re given two signed messages that were generated using the same value for <code>k</code>.</p>
<p>For each signed message we have the <em>message hash</em> <code>z</code>, and also the <code>r</code> and <code>s</code> values from each of the respective signatures:</p>
<pre><code>Signed Message 1: (z₁, r₁, s₁)
Signed Message 2: (z₂, r₂, s₂)</code></pre>
<p>However, because the same value for <code>k</code> was used each time to generate the random point (<code>R = k*G</code>), the <code>r</code> value (x-coordinate of <code>R</code>) in each of these signatures will also be the same:</p>
<pre><code>Signed Message 1: (z₁, r, s₁)
Signed Message 2: (z₂, r, s₂)</code></pre>
<p class="mb4">
So how can we use this information to work out the private key <code>d</code>?
</p>
<p>First of all, we know that the <code>s</code> value in each of these signatures was calculated using <code>s = k⁻¹(z + r * d) mod n</code>, so:</p>
<pre><code>s₁ = k⁻¹(z₁ + r * d) mod n
s₂ = k⁻¹(z₂ + r * d) mod n</code></pre>
<p>And thanks to the fact that both equations now have the same value for <code>k</code>, we can solve them as a pair of simultaneous equations to work out the value for <code>k</code>.</p>
<p>To do this, we start by rearranging the second equation to get <code>r * d</code> on its own:</p>
<pre><code>s₂ = k⁻¹(z₂ + r * d) mod n
r * d = k * s₂ - z₂ mod n</code></pre>
<p>Then we can substitute this in to the first equation, and rearrange it to get <code>k</code>:</p>
<pre><code>s₁ = k⁻¹(z₁ + r * d) mod n
s₁ = k⁻¹(z₁ + (k * s₂ - z₂)) mod n
k = (z₁ - z₂) * (s₁ - s₂)⁻¹ mod n</code></pre>
<p class="note text">Remember that multiplying by <code>(s₁ - s₂)⁻¹</code> means multiplying by the <em>modular multiplicative inverse</em> of <code>(s₁ - s₂)</code>, which is the same thing as “division” in elliptic curve mathematics.</p>
<p>And after we’ve worked out <code>k</code>, we can use it in <code>s = k⁻¹(z + r * d) mod n</code> again to work out <code>d</code>.</p>
<p>So rearranging the first equation (you can use either) to get <code>d</code> on its own:</p>
<pre><code>s₁ = k⁻¹(z₁ + r * d) mod n
d = (k * s₁ - z₁) * r⁻¹ mod n</code></pre>
<p>And because we already knew <code>(z₁, r, s₁)</code> and have just worked out <code>k</code>, we can plug them all in to this equation to work out the private key <code>d</code>.</p>
<p>In mathematical notation, the private key recovery looks like this:</p>
<p><a target='_blank' href='../images/58.latex-private-key-recovery.png'><img class='clImageThumb' src='../images/58.latex-private-key-recovery.png'></a><br><br></p>
<p><strong>So make sure you always use securely random values for <code>k</code> each time you create a signature.</strong> If someone spots you’ve used the same <code>r</code> value when signing different messages for the same public key, it only takes milliseconds for them to recover your private key.</p>
<p class="note text">In 2011 hackers worked out how to get the private key for the PS3 because Sony were using the same value for <code>k</code> when generating their signatures.</p>
<p>Here’s an example of recovering a private key from two signatures using the same <code>k</code> in Ruby:</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span>require <span class="st">&#39;digest&#39;</span> <span class="co"># used for hashing messages before signing</span></span>
<span></span>
<span><span class="co"># Note: This code uses the previously defined inverse(), double(), add(), multiply(), and sign() functions</span></span>
<span></span>
<span><span class="co"># -------------</span></span>
<span><span class="co"># Sign Messages</span></span>
<span><span class="co"># -------------</span></span>
<span></span>
<span><span class="co"># 0. Keys</span></span>
<span>prv = <span class="dv">1111222233334444555566667777888899990000</span> <span class="co"># any old private key</span></span>
<span>pub = multiply(prv)</span>
<span></span>
<span><span class="co"># 1. Create first signed message</span></span>
<span>k    = <span class="dv">800000</span></span>
<span>z1   = <span class="dt">Digest</span>::<span class="dt">SHA256</span>.hexdigest(<span class="st">&quot;Just a simple message.&quot;</span>).to_i(<span class="dv">16</span>)</span>
<span>sig1 = sign(prv, z1, k)</span>
<span></span>
<span><span class="co"># 2. Create second signed message</span></span>
<span>k    = <span class="dv">800000</span> <span class="co"># Using the same value for k!</span></span>
<span>z2   = <span class="dt">Digest</span>::<span class="dt">SHA256</span>.hexdigest(<span class="st">&quot;I have used the same k value.&quot;</span>).to_i(<span class="dv">16</span>)</span>
<span>sig2 = sign(prv, z2, k)</span>
<span></span>
<span><span class="co"># --------------------</span></span>
<span><span class="co"># Private Key Recovery</span></span>
<span><span class="co"># --------------------</span></span>
<span><span class="co"># k = (z₁ - z₂) * (s1 - s₂)⁻¹  mod n</span></span>
<span><span class="co"># d = (k * s₁ - z₁) * r⁻¹    mod n</span></span>
<span></span>
<span><span class="co"># 1. Work out k (note: result may be the additive inverse of original k, but it still works fine)</span></span>
<span>k_calculated = ((z1 - z2) * inverse(sig1[<span class="st">:s</span>] - sig2[<span class="st">:s</span>], <span class="dt">$n</span>)) % <span class="dt">$n</span></span>
<span></span>
<span><span class="co"># 2. Work out d (the original private key)</span></span>
<span>d_calculated = ((k_calculated * sig1[<span class="st">:s</span>] - z1) * inverse(sig1[<span class="st">:r</span>], <span class="dt">$n</span>)) % <span class="dt">$n</span></span>
<span>puts d_calculated <span class="co">#=&gt; 1111222233334444555566667777888899990000</span></span></code></pre></div>
</details>
<h3>Verify</h3>
<p>You can verify a message and its signature with three things:</p>
<ol type="1">
<li><strong><code class="publickey">Public Key</code></strong> <code>Q</code> — This is the public key for the person claiming to have created the signature.</li>
<li><strong>Message</strong> — The data that was signed. We can hash it ourselves to get the <em>message hash</em> <code>z</code>.</li>
<li><strong>Signature</strong> <code>[r, s]</code> — This is the signature created for the above message, allegedly created by the person who has the <code class="privatekey">private key</code> for the <code class="publickey">public key</code>.</li>
</ol>
<p class="mt4">
We then use these three pieces of data to <em>calculate two points</em> on the curve:
</p>
<ul>
<li><strong>Point 1.</strong> Start with the <em>generator point</em> <code>G</code>, and multiply it by <code>inverse(s) * z</code>.</li>
<li><strong>Point 2.</strong> Start with the <code class="publickey">public key</code> point <code>Q</code>, and multiply it by <code>inverse(s) * r</code>.</li>
</ul>
<p>We can now add these points together to give us <strong>Point 3</strong>:</p>
<p><a target='_blank' href='../images/58.point-verify.gif'><img class='clImageThumb' src='../images/58.point-verify.gif'></a><br><br></p>
<p><a target='_blank' href='../images/58.latex-verify.png'><img class='clImageThumb' src='../images/58.latex-verify.png'></a><br><br></p>
<p><strong>If this third point matches up with the random point given, the signature is valid</strong>.</p>
<p class="mt4">
For example:
</p>
<pre class="f6"><code>message:             ECDSA is the most fun I have ever experienced
sha256(message) (z): 103318048148376957923607078689899464500752411597387986125144636642406244063093
signature (r,s): {
  r = 108607064596551879580190606910245687803607295064141551927605737287325610911759,
  s = 73791001770378044883749956175832052998232581925633570497458784569540878807131
}
public key (Q): {
  x = 33886286099813419182054595252042348742146950914608322024530631065951421850289,
  y = 9529752953487881233694078263953407116222499632359298014255097182349749987176
}

verification (s⁻¹ * z)G + (s⁻¹ * r)Q: {
  x = 108607064596551879580190606910245687803607295064141551927605737287325610911759, <- matches r (x-coordinate of random point)
  y = 6661302038839728943522144359728938428925407345457796456954441906546235843221
}</code></pre>
<p>In other words, the signature for this message could only have been created by the person who has the actual <code class="privatekey">private key</code> that the <code class="publickey">public key</code> was created from. Nobody else can give you an <code>s</code> value that you can use in combination with the <code class="publickey">public key</code> <code>Q</code> to reach the random point <code>R</code> <em>unless</em> they knew the <code class="privatekey">private key</code> <code>d</code> for that public key.</p>
<p>If you change the contents of the signed message or try to use the signature with a different <code class="publickey">public key</code>, the resulting third point won’t match up with the random point given in the signature, and the signature verification will fail.</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="kw">def</span> verify(public_key, signature, hash)</span>
<span>  <span class="co"># point 1</span></span>
<span>  point1 = multiply(inverse(signature[<span class="st">:s</span>], <span class="dt">$n</span>) * hash)</span>
<span></span>
<span>  <span class="co"># point 2</span></span>
<span>  point2 = multiply((inverse(signature[<span class="st">:s</span>], <span class="dt">$n</span>) * signature[<span class="st">:r</span>]), public_key)</span>
<span></span>
<span>  <span class="co"># add two points together</span></span>
<span>  point3 = add(point1, point2)</span>
<span></span>
<span>  <span class="co"># check x coordinate of this point matches the x-coordinate of the random point given</span></span>
<span>  <span class="kw">return</span> point3[<span class="st">:x</span>] == signature[<span class="st">:r</span>]</span>
<span><span class="kw">end</span></span></code></pre></div>
<details class="mb4">
<summary>
<strong>Why does this work?</strong> (Mathematical Explanation)
</summary>
<p><strong>Signing:</strong></p>
<p>The person creating a signature starts by using a random number <code>k</code> to generate a random point on the curve:</p>
<pre><code>R = k * G</code></pre>
<p>They then compute an auxillary number using their private key <code>d</code> and the hash of the message <code>z</code> (along with <code>r</code> (the x-coordinate of <code>R</code>) and the random number <code>k</code>):</p>
<pre><code>s = k⁻¹ * (z + r * d)</code></pre>
<p><br> <strong>Verifying:</strong></p>
<p>The following equation allows you to calculate the <em>same point</em> by using the public key <code>Q</code> alongside the hash of the message <code>z</code> and the given <code>s</code> value:</p>
<pre><code>R = (s⁻¹ * z)G + (s⁻¹ * r)Q</code></pre>
<p>We can now rearrange this equation and substitute some values to prove that this equation does indeed get us to the same point.</p>
<p>To start with, the public key <code>Q</code> is <code>d * G</code>, so:</p>
<pre><code>R = (s⁻¹ * z)G + (s⁻¹ * r)d*G</code></pre>
<p>If we rearrange this equation we get:</p>
<pre><code>R = (s⁻¹ * z)G + (s⁻¹ * r * d)G
R = s⁻¹ * (z + r * d) * G</code></pre>
<p>Now, remember that <code>s = k⁻¹ * (z + r * d)</code>. If we rearrange this to get <code>k</code> on its own we get <code>k = s⁻¹ * (z + r * d)</code>, and substituting this in to the equation above:</p>
<pre><code>R = k * G</code></pre>
And that’s the same calculation that was used to generate the random point in the first place.
</details>
<h2>ECDSA in Bitcoin</h2>
<p>ECDSA is used in Bitcoin when:</p>
<ol type="1">
<li>Creating a public key</li>
<li>Signing a transaction</li>
</ol>
<p>In both of these situations you’re just using the exact same elliptic curve mathematics as above.</p>
<p>Most of the time the only tricky part is getting the data in to the correct format.</p>
<h3>1. Creating a public key</h3>

<a target='_blank' href='../images/58.creating-a-public-key.png'><img class='clImageThumb' src='../images/58.creating-a-public-key.png'></a><br><br>
<p class='clFigcaption'>A <code class="publickey">public key</code> can be put inside the locking script on top of an output.</p>


<p>A <code class="publickey">public key</code> is just the generator point multiplied by your <code class="privatekey">private key</code>.</p>
<p>So it’s a <strong>point on the curve</strong> made up of <code>x</code> and <code>y</code> coordinates:</p>
<pre class="f6"><code>private key = 112757557418114203588093402336452206775565751179231977388358956335153294300646
public key  = {
    x: 33886286099813419182054595252042348742146950914608322024530631065951421850289,
    y: 9529752953487881233694078263953407116222499632359298014255097182349749987176
}
</code></pre>
<p>When converting this point in to the common format used in Bitcoin, you essentially just convert each coordinate to hexadecimal:</p>
<pre class="f6"><code>public key  = {
    x: 4aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1,
    y: 1511a626b232de4ed05b204bd9eccaf1b79f5752e14dd1e847aa2f4db6a52768
}

public key = 4aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b11511a626b232de4ed05b204bd9eccaf1b79f5752e14dd1e847aa2f4db6a52768
</code></pre>
<p class="note text">Don’t forget to pad each hexadecimal coordinate to 32 bytes (64 characters) by prepending zeros if necessary.</p>
<p>However, one interesting thing about the elliptic curve used in ECDSA is that every <code>x</code> coordinate will have one of <em>two</em> possible <code>y</code> coordinates (one is even and the other is odd).</p>

<a target='_blank' href='../images/58.elliptic-curve-symmetry.png'><img class='clImageThumb' src='../images/58.elliptic-curve-symmetry.png'></a><br><br>
<p class='clFigcaption'>Elliptic curves are symmetrical.</p>


<p>So instead of having to use the full <code>y</code> coordinate all the time, we can use a <em>prefix</em> to indicate which of the two possible <code>y</code> coordinates we’re using for a given point. This halves the size of a formatted public key, and reduces the amount of data required when building transactions.</p>
<pre class="f6"><code>Public key prefixes:

02 = compressed (y is even)
03 = compressed (y is odd)
04 = uncompressed (full y is included)
</code></pre>
<p>With our example public key we can see that the <code>y</code> coordinate is even, so we can just use a <code>02</code> prefix alongside the full <code>x</code> coordinate to shorten the encoded public key:</p>
<pre class="f6"><code>public key (uncompressed) = 044aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b11511a626b232de4ed05b204bd9eccaf1b79f5752e14dd1e847aa2f4db6a52768
public key (compressed)   = 024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1
</code></pre>
<p>These shortened public keys are called <strong>compressed public keys</strong>, and they’re the preferred format for use in Bitcoin.</p>
<p>And finally, as mentioned, these public keys can then be used for <em>receiving</em> bitcoin by putting them inside a scriptPubKey (the “locking script”) on an output in a transaction. This effectively encumbers a fixed amount of bitcoin with a public key, and only the owner of this public key will be able to spend them later on.</p>
<p class="mt4">
The following code shows how you can convert a <code class="privatekey">private key</code> in to a compressed <code class="publickey">public key</code> that can be used for receiving bitcoin:
</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="co"># Example private key (in hexadecimal)</span></span>
<span>private_key = <span class="st">&quot;f94a840f1e1a901843a75dd07ffcc5c84478dc4f987797474c9393ac53ab55e6&quot;</span></span>
<span></span>
<span><span class="co"># Public key is the generator point multiplied by the private key</span></span>
<span>point = multiply(private_key.to_i(<span class="dv">16</span>))</span>
<span></span>
<span><span class="co"># convert x and y values of the public key point to hexadecimal</span></span>
<span>x = point[<span class="st">:x</span>].to_s(<span class="dv">16</span>).rjust(<span class="dv">64</span>, <span class="st">&quot;0&quot;</span>) <span class="co"># pad with zeros to make sure it&#39;s 64 characters (32 bytes)</span></span>
<span>y = point[<span class="st">:y</span>].to_s(<span class="dv">16</span>).rjust(<span class="dv">64</span>, <span class="st">&quot;0&quot;</span>)</span>
<span></span>
<span><span class="co"># uncompressed public key (use full x and y coordinates) OLD FORMAT!</span></span>
<span>public_key_uncompressed = <span class="st">&quot;04&quot;</span> + x + y</span>
<span></span>
<span><span class="co"># compressed public key (use a prefix to indicate whether y is even or odd)</span></span>
<span><span class="kw">if</span> (point[<span class="st">:y</span>] % <span class="dv">2</span> == <span class="dv">0</span>)</span>
<span>  public_key_compressed = <span class="st">&quot;02&quot;</span> + x <span class="co"># y is even</span></span>
<span><span class="kw">else</span></span>
<span>  public_key_compressed = <span class="st">&quot;03&quot;</span> + x <span class="co"># y is odd</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co">#puts public_key_compressed #=&gt; 024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1</span></span></code></pre></div>
<p class="note text">A <code class="privatekey">private key</code> is just a large randomly generated number. If you’ve got a <code class="privatekey">private key</code> as a <em>hexadecimal</em> string you can always convert it back to an <em>integer</em> so it can be used for elliptic curve multiplication.</p>
<h3>2. Signing a transaction</h3>
<p><a target='_blank' href='../images/58.creating-a-signature.png'><img class='clImageThumb' src='../images/58.creating-a-signature.png'></a><br><br></p>
<p>When you want to send bitcoins to someone, you need to be able to provide a digital signature that prove you’ve got the <code class="privatekey">private key</code> for the <code class="publickey">public key</code> that the bitcoins have been locked to.</p>
<p>This involves:</p>
<ol type="1">
<li>Constructing a transaction. This will be the <em>message</em> that we sign.</li>
<li>Using your private key to sign this message.</li>
<li>Putting this signature back inside the transaction.</li>
</ol>

<p>Signing transactions in Bitcoin can be a little tricky, but it’s <strong>mostly just getting data in to the correct format</strong>. Here are the full steps for signing a classic bitcoin transaction:</p>
<p><a target='_blank' href='../images/58.signing-a-transaction.png'><img class='clImageThumb' src='../images/58.signing-a-transaction.png'></a><br><br></p>
<ol start="0" type="1">
<li>Create a transaction</li>
<li>Remove existing unlocking scripts</li>
<li>Put the locking script as a placeholder</li>
<li>Append signature hash type to transaction data</li>
<li>Hash the transaction data</li>
<li>Sign the transaction hash</li>
<li>Use the low-s value</li>
<li>DER encode the signature</li>
<li>Append signature hash type to DER encoded signature</li>
<li>Construct unlocking script</li>
<li>Insert the unlocking script in to the transaction</li>
</ol>
<h4>0. Create a transaction.</h4>
<p>To begin with, you want to create some transaction data that spends bitcoins that you own.</p>
<p>This is basically where you <strong>select the inputs</strong> you want to spend, and then <strong>create the outputs</strong> you want to lock those spent inputs to. In other words, it <em>describes the movement</em> of coins.</p>
<p><a target='_blank' href='../images/58.transaction-structure.png'><img class='clImageThumb' src='../images/58.transaction-structure.png'></a><br><br></p>
<p>I haven’t explained bitcoin transaction data structure here, so this part will be confusing if you’ve never seen a raw transaction before, but this is what one looks like:</p>
<pre class="f6 pre-wrap break-word"><code>Raw Transaction (Unsigned):

version: 01000000
inputs:  01
  txid: b7994a0db2f373a29227e1d90da883c6ce1cb0dd2d6812e4558041ebbbcfa54b
  vout: 00000000
  scriptsigsize: 00
  scriptsig:
  sequence: ffffffff
outputs: 01
  amount: 983a000000000000
  scriptpubkeysize: 19
  scriptpubkey: 76a914b3e2819b6262e0b1f19fc7229d75677f347c91ac88ac
locktime: 00000000
</code></pre>
<p class="note text">The TXIDs used to reference inputs inside raw transaction data are actually in <em>reverse byte order</em>. This is a quirk of bitcoin.</p>
<p>Here I’ve selected the bitcoins I want to spend by referencing the <code>txid</code> and a specific <code>vout</code> (output) from a previous transaction, and I’ve created a new output containing an <code>amount</code> of bitcoins with a new <code>scriptpubkey</code> lock on it. This output uses a P2PKH lock, but that’s not important for now.</p>
<p>Most importantly, notice that <strong>the <code>scriptSig</code> for the input is currently empty</strong>. This is where an unlocking script containing our signature will go.</p>
<p>Anyway, we are now ready to sign this transaction data and “unlock” the input we’ve selected…</p>
<h4>1. Remove existing unlocking scripts</h4>
<p>When we sign a transaction we only sign the data that describes the movement of coins. So if you’ve already created <code>scriptSig</code>s (unlocking scripts) for other inputs, remove them from the transaction temporarily.</p>
<p>In my transaction I’m only unlocking one input, so I don’t have to remove any existing <code>scriptSig</code>s.</p>
<h4>2. Put the locking script as a placeholder</h4>
<p>Before signing an input, we need to put that input’s original locking script (<code>scriptpubkey</code>) in to the place where the signature for it is about to go (the <code>scriptsig</code>).</p>
<p>I’m not entirely sure why this is the case, but I’m guessing it helps to identify the specific input we want to sign, and also shows that we’re aware of the original locking script on the output we intend to spend.</p>
<p>Anyway, looking at the raw transaction data for this input we can see that it has a P2PKH locking script of <code>76a9144299ff317fcd12ef19047df66d72454691797bfc88ac</code>, so we put that in to the <code>scriptsig</code> as a placeholder:</p>
<pre class="f6 pre-wrap break-word"><code>Raw Transaction (Unsigned):

version: 01000000
inputs:  01
  txid: b7994a0db2f373a29227e1d90da883c6ce1cb0dd2d6812e4558041ebbbcfa54b
  vout: 00000000
  scriptsigsize: 19
  scriptsig: 76a9144299ff317fcd12ef19047df66d72454691797bfc88ac
  sequence: ffffffff
outputs: 01
  amount: 983a000000000000
  scriptpubkeysize: 19
  scriptpubkey: 76a914b3e2819b6262e0b1f19fc7229d75677f347c91ac88ac
locktime: 00000000
</code></pre>
<p class="note text">Don’t forget that this placeholder will adjust the value of <code>scriptsigsize</code> temporarily too.</p>
<h4>3. Append signature hash type to transaction data</h4>
<p><a target='_blank' href='../images/58.sighash-types.png'><img class='clImageThumb' src='../images/58.sighash-types.png'></a><br><br></p>
<pre class="f6 pre-wrap break-word"><code>Signature Hash Types:

0x01 = SIGHASH_ALL
0x02 = SIGHASH_NONE
0x03 = SIGHASH_SINGLE
0x81 = SIGHASH_ANYONECANPAY | SIGHASH_ALL
0x82 = SIGHASH_ANYONECANPAY | SIGHASH_NONE
0x83 = SIGHASH_ANYONECANPAY | SIGHASH_SINGLE
</code></pre>
<p>At this point we can indicate <em>how much</em> of the transaction’s structure we are going to be signing by appending a signature hash type (<code>SIGHASH</code>) to the end of the transaction data.</p>
<p>The most common is <code>SIGHASH_ALL</code> (<code>0x01</code>), which indicates that the signature <strong>covers all of the inputs and outputs</strong> in the transaction, which means that nobody else can add any additional inputs or outputs to it later on.</p>
<p>So this is what our raw unsigned transaction looks like now:</p>
<pre class="f6 pre-wrap break-word"><code>Raw Transaction (Unsigned):

version: 01000000
inputs:  01
  txid: b7994a0db2f373a29227e1d90da883c6ce1cb0dd2d6812e4558041ebbbcfa54b
  vout: 00000000
  scriptsigsize: 19
  scriptsig: 76a9144299ff317fcd12ef19047df66d72454691797bfc88ac
  sequence: ffffffff
outputs: 01
  amount: 983a000000000000
  scriptpubkeysize: 19
  scriptpubkey: 76a914b3e2819b6262e0b1f19fc7229d75677f347c91ac88ac
locktime: 00000000
sighash: 01000000
</code></pre>
<p class="note text">The <code>sighash</code> here is 4 bytes long, and also in little-endian byte order.</p>
<p class="note text">You may need to adjust the transaction data based on your choice of signature hash type. But for <code>SIGHASH_ALL</code> the current transaction structure is ready for signing.</p>
<h4>4. Hash the transaction data</h4>
<p>Now that we’ve prepared the raw unsigned transaction, we can now create a hash of it ready for signing.</p>

<p>Bitcoin uses <em>double</em> SHA-256 when hashing things (also referred to hash “hash256”), so if we serialize our current unsigned transaction and hash it we get:</p>
<pre class="f6 pre-wrap break-word"><code>message: 0100000001b7994a0db2f373a29227e1d90da883c6ce1cb0dd2d6812e4558041ebbbcfa54b000000001976a9144299ff317fcd12ef19047df66d72454691797bfc88acffffffff01983a0000000000001976a914b3e2819b6262e0b1f19fc7229d75677f347c91ac88ac0000000001000000

hash256(message): a6b4103f527dfe43dfbadf530c247bac8a98b7463c7c6ad38eed97021d18ffcb
</code></pre>
<p>If we convert this hash to an integer we have:</p>
<pre class="f6 pre-wrap break-word"><code>hash256(message): 75402077471587956851360588120356244127735644006942973877340910814730793844683</code></pre>
<p class="note text"><code>hash256(message)</code> is shorthand for <code>sha256(sha256(message))</code>. You almost always use double SHA-256 when hashing data in Bitcoin.</p>
<h4>5. Sign the transaction hash</h4>
<p>Now we can just sign this message hash <code>z</code> like we would for any other message in ECDSA. All we need is our private key <code>d</code> and a randomly generated number <code>k</code>.</p>
<p>This is what the signature for this transaction looks like:</p>
<pre class="f6 pre-wrap break-word"><code>random number    (k): 123456789
hash256(message) (z): 75402077471587956851360588120356244127735644006942973877340910814730793844683
private key      (d): 112757557418114203588093402336452206775565751179231977388358956335153294300646

random point (k*G = R): {
  x = 4051293998585674784991639592782214972820158391371785981004352359465450369227,
  y = 88166831356626186178414913298033275054086243781277878360288998796587140930350
}

signature: r = R[x], s = k⁻¹ * (z + r * d): {
  r = 4051293998585674784991639592782214972820158391371785981004352359465450369227,
  s = 101656099268479774907861155236876278987061611115278341531512875302287938750185
}
</code></pre>
<h4>6. Use the low-s value</h4>
<p>Interestingly, there are actually two possible <code>s</code> values in ECDSA that will make for a valid signature. We call one the “high” <code>s</code> value and we call the other the “low” <code>s</code> value.</p>
<p>In mathematical terms, the “other” valid <code>s</code> value is just the <em>additive inverse</em> of our current <code>s</code> value in the finite field of <code>n</code>. As a result, both of these <code>s</code> values will actually get you to the same <em>x-coordinate</em> of the random point <code>R</code> when doing signature verification.</p>

<a target='_blank' href='../images/58.point-low-s.png'><img class='clImageThumb' src='../images/58.point-low-s.png'></a><br><br>
<p class='clFigcaption'>The additive inverse of <code>s</code> value calculates the opposite points on the curve during signature validation, but the x-coordinate of the third point will be the same.</p>


<p>Anyway, in Bitcoin this feature is a bit annoying, because it means that anyone could invert the <code>s</code> value in our signature after we send our transaction in to the network, and this would alter the resulting TXID. This doesn’t change the actual structure of the transaction (the money moves to the same place in the same way), but it does mean we lose the ability to reliably keep track of the transaction in the blockchain.</p>
<p>So to help remedy this high/low <code>s</code> value problem, BIP 62 introduced a rule where all signatures should use the <strong>low <code>s</code></strong> value by default, otherwise the transaction is considered non-standard<sup>2</sup> and will not be relayed by nodes.</p>
<p>You’ll know if you’ve ended up with the “high” <code>s</code> value because it will be in the upper half of the finite field of <code>n</code> (i.e. <code>s &gt; n/2</code>). If this is the case (such as with our <code>s</code> value), we just subtract <code>s</code> value from <code>n</code> to give us the “low” <code>s</code> value:</p>
<pre class="f6 pre-wrap break-word"><code>n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;115792089237316195423570985008687907852837564279074904382605163141518161494337

s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;101656099268479774907861155236876278987061611115278341531512875302287938750185&nbsp;&nbsp;<- high s value
n&nbsp;-&nbsp;s&nbsp;=&nbsp;14135989968836420515709829771811628865775953163796562851092287839230222744152&nbsp;&nbsp;&nbsp;<- low s value
</code></pre>
<p>In Ruby code this is as simple as:</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="kw">if</span> (signature[<span class="st">:s</span>] &gt; <span class="dt">$n</span> / <span class="dv">2</span>)</span>
<span>  signature[<span class="st">:s</span>] = <span class="dt">$n</span> - signature[<span class="st">:s</span>]</span>
<span><span class="kw">end</span></span></code></pre></div>
<p>As I say, both <code>s</code> values are technically valid – it’s just in Bitcoin we use the low <code>s</code> value to help prevent transaction malleability.</p>
<h4>7. DER encode the signature</h4>
<p>The next step is to <strong>format the signature</strong> ready to be put inside a bitcoin transaction.</p>
<p>Bitcoin uses DER encoding for signatures, which is a bit verbose, but it’s what Satoshi chose, so now we have to use it when encoding signatures for transactions.</p>

<p>Why did Satoshi decided to use DER encoding?…</p>
<blockquote>
<p>My guess is that Satoshi did not know about the internals of ECDSA signatures, and simply used what OpenSSL gave him. If it didn’t require a hard forking change (requiring every wallet and verifying node on the network to upgrade), we’d have changed it long ago. <br><br>– Pieter Wuille</p>
</blockquote>
<p>Anyway, DER encoding signatures in Bitcoin basically involves converting the <code>r</code> and <code>s</code> values to hexadecimal, and adding a few bytes in between to indicate the <em>length</em> and <em>type</em> of data. There’s also a quirk where if the first byte of <code>r</code> or <code>s</code> is <code>0x80</code> or above, we prepend a zero <code>0x00</code> byte to them respectively. But other than that, it’s pretty straightforward.</p>
<p>So if this is our raw signature:</p>
<pre class="f6 pre-wrap break-word"><code>signature: {
  r = 4051293998585674784991639592782214972820158391371785981004352359465450369227,
  s = 14135989968836420515709829771811628865775953163796562851092287839230222744152
}
</code></pre>
<p>This is what it looks like in DER encoding:</p>
<pre class="f6 pre-wrap break-word"><code>der encoded:
type: 30
  length: 44
  type:   02
    length: 20
    r:      08f4f37e2d8f74e18c1b8fde2374d5f28402fb8ab7fd1cc5b786aa40851a70cb
  type:   02
    length: 20
    s:      1f40afd1627798ee8529095ca4b205498032315240ac322c9d8ff0f205a93a58
</code></pre>
<p>The type bytes <code>0x30</code> and <code>0x20</code> are always the same. It’s only the <em>length</em> and actual <em>data</em> fields that you need to change when encoding a signature in DER format.</p>
<p><small>See this stackexchange.com post for more details.</small></p>
<h4>8. Append signature hash type to DER encoded signature</h4>
<p>After encoding our signature in to DER format we once again append the <code>SIGHASH</code> type to indicate how much of the transaction data this signature applies to. This must be the same as the signature hash type we chose in step 3.</p>
<p>So this is what our encoded signature looks like now:</p>
<pre class="f6 pre-wrap break-word"><code>der encoded (with SIGHASH):
type: 30
  length: 44
  type:   02
    length: 20
    r:      08f4f37e2d8f74e18c1b8fde2374d5f28402fb8ab7fd1cc5b786aa40851a70cb
  type:   02
    length: 20
    s:      1f40afd1627798ee8529095ca4b205498032315240ac322c9d8ff0f205a93a58
sighash: 01
</code></pre>
<p class="note text">The <code>SIGHASH</code> type here is 1 byte, even though the <code>SIGHASH</code> type we appended to the transaction data before hashing is 4 bytes. This is just another quirk of bitcoin.<sup>3</sup></p>
<p>The reason we appended the <code>SIGHASH</code> type <em>before</em> hashing is because it allows us to commit to that <code>SIGHASH</code> type before we create the signature. In other words, if someone changes this second value to something like <code>SIGHASH_ANYONECANPAY</code> (which suggests anyone could add more inputs to the transaction), it will not match the <code>SIGHASH</code> value we chose when we hashed and signed the initial transaction data.</p>
<p>Anyway, if we serialize all of this data our encoded signature looks like:</p>
<pre class="f6 pre-wrap break-word"><code>der encoded (with SIGHASH):
3044022008f4f37e2d8f74e18c1b8fde2374d5f28402fb8ab7fd1cc5b786aa40851a70cb02201f40afd1627798ee8529095ca4b205498032315240ac322c9d8ff0f205a93a5801
</code></pre>
<h4>9. Construct unlocking script</h4>
<p>As a final step, we need to place this signature in to a script that will unlock the the input.</p>
<p><a target='_blank' href='../images/58.p2pkh.gif'><img class='clImageThumb' src='../images/58.p2pkh.gif'></a><br><br></p>
<p>I’m not going to cover the mechanics of script here, but let’s just say that our chosen input has the following P2PKH locking script (<code>scriptpubkey</code>) on it:</p>
<pre class="f6"><code>scriptpubkey:

asm: OP_DUP OP_HASH [length] [public key hash] OP_EQUALVERIFY OP_CHECKSIG
hex: 76a9144299ff317fcd12ef19047df66d72454691797bfc88ac
</code></pre>
<p>In short, this input has been locked to the <em>hash</em> of our public key. To unlock it, we need to provide a valid <code class="signature">signature</code> <em>alongside</em> the <em>original</em> <code class="publickey">public key</code>.</p>
<p>So if this is the <code class="publickey">public key</code> and our <code class="signature">signature</code>:</p>
<pre class="f6"><code>public key:&nbsp;024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1
signature:&nbsp;&nbsp;3044022008f4f37e2d8f74e18c1b8fde2374d5f28402fb8ab7fd1cc5b786aa40851a70cb02201f40afd1627798ee8529095ca4b205498032315240ac322c9d8ff0f205a93a5801
</code></pre>
<p>This is what our unlocking script (<code>scriptsig</code>) looks like:</p>
<pre class="f6"><code>scriptpubkey:

asm: [signature length] [signature] [public key length] [public key]
hex:&nbsp;473044022008f4f37e2d8f74e18c1b8fde2374d5f28402fb8ab7fd1cc5b786aa40851a70cb02201f40afd1627798ee8529095ca4b205498032315240ac322c9d8ff0f205a93a580121024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1
</code></pre>
<p>This is just the DER-encoded signature followed by the public key, with <code>0x47</code> and <code>0x21</code> bytes before each to indicate their length.</p>
<h4>10. Insert the unlocking script in to the transaction</h4>
<p>Finally, we just pop this unlocking script in to the transaction:</p>
<pre class="f6 pre-wrap break-word"><code>Raw Transaction (Signed):

version: 01000000
inputs:  01
  txid: b7994a0db2f373a29227e1d90da883c6ce1cb0dd2d6812e4558041ebbbcfa54b
  vout: 00000000
  scriptsigsize: 6a
  scriptsig: 473044022008f4f37e2d8f74e18c1b8fde2374d5f28402fb8ab7fd1cc5b786aa40851a70cb02201f40afd1627798ee8529095ca4b205498032315240ac322c9d8ff0f205a93a580121024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1
  sequence: ffffffff
outputs: 01
  amount: 983a000000000000
  scriptpubkeysize: 19
  scriptpubkey: 76a914b3e2819b6262e0b1f19fc7229d75677f347c91ac88ac
locktime: 00000000
</code></pre>
<p class="note tip"><strong>Note:</strong> Repeat steps 1-9 for each input you want to unlock.</p>
<p class="mt5">
Finally, if we serialize this transaction data we get:
</p>
<pre class="f6 pre-wrap break-word"><code>Raw Transaction (Signed):

0100000001b7994a0db2f373a29227e1d90da883c6ce1cb0dd2d6812e4558041ebbbcfa54b000000006a473044022008f4f37e2d8f74e18c1b8fde2374d5f28402fb8ab7fd1cc5b786aa40851a70cb02201f40afd1627798ee8529095ca4b205498032315240ac322c9d8ff0f205a93a580121024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1ffffffff01983a0000000000001976a914b3e2819b6262e0b1f19fc7229d75677f347c91ac88ac00000000
</code></pre>
<p>
And that’s a valid transaction that we can send in to the bitcoin network.
</p>
<div class="note command">
<h4>
<code>bitcoin-cli sendrawtransaction</code>
</h4>
<p>Send some raw transaction data in to the bitcoin network. For example:</p>
<pre class="f6 pre-wrap break-word"><code>$ bitcoin-cli sendrawtransaction 0100000001b7994a0db2f373a29227e1d90da883c6ce1cb0dd2d6812e4558041ebbbcfa54b000000006a473044022008f4f37e2d8f74e18c1b8fde2374d5f28402fb8ab7fd1cc5b786aa40851a70cb02201f40afd1627798ee8529095ca4b205498032315240ac322c9d8ff0f205a93a580121024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1ffffffff01983a0000000000001976a914b3e2819b6262e0b1f19fc7229d75677f347c91ac88ac00000000</code></pre>
</div>

<p class="mt5">
The following code shows how you can sign a transaction using the steps above:
</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="co"># A basic structure for holding the transaction data</span></span>
<span><span class="kw">def</span> tx(scriptsig)</span>
<span>  <span class="co"># Need to calculate a byte indicating the size of upcoming scriptsig in bytes (rough code but does the job)</span></span>
<span>  size = (scriptsig.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>)</span>
<span></span>
<span>  <span class="co"># Raw unsigned transaction data with the scriptsig field (you need to know the correct position)</span></span>
<span>  <span class="kw">return</span> <span class="st">&quot;0100000001b7994a0db2f373a29227e1d90da883c6ce1cb0dd2d6812e4558041ebbbcfa54b00000000</span><span class="ot">#{</span>size<span class="ot">}#{</span>scriptsig<span class="ot">}</span><span class="st">ffffffff01983a0000000000001976a914b3e2819b6262e0b1f19fc7229d75677f347c91ac88ac00000000&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># Private key and public key for the locked up bitcoins we want to spend</span></span>
<span>private_key = <span class="st">&quot;f94a840f1e1a901843a75dd07ffcc5c84478dc4f987797474c9393ac53ab55e6&quot;</span> <span class="co"># sha256(&quot;learnmeabitcoin1&quot;)</span></span>
<span>public_key = <span class="st">&quot;024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1&quot;</span></span>
<span></span>
<span><span class="co"># </span><span class="al">NOTE</span><span class="co">: Need to remove all existing signatures from the transaction data first if there are any</span></span>
<span></span>
<span><span class="co"># Put original scriptpubkey as a placeholder in to the scriptsig for the input you want to sign (required)</span></span>
<span>scriptpubkey = <span class="st">&quot;76a9144299ff317fcd12ef19047df66d72454691797bfc88ac&quot;</span> <span class="co"># just one input in this transaction</span></span>
<span>transaction = tx(scriptpubkey)</span>
<span></span>
<span><span class="co"># Append sighash type to transaction data (required)</span></span>
<span>transaction = transaction + <span class="st">&quot;01000000&quot;</span></span>
<span></span>
<span><span class="co"># Get a hash of the transaction data (because we sign the hash of data and not the actual data itself)</span></span>
<span>hash = <span class="dt">Digest</span>::<span class="dt">SHA256</span>.hexdigest(<span class="dt">Digest</span>::<span class="dt">SHA256</span>.digest([transaction].pack(<span class="st">&quot;H*&quot;</span>)))</span>
<span></span>
<span><span class="co"># Use elliptic curve mathematics to sign the hash using the private key and nonce</span></span>
<span>signature = sign(private_key.to_i(<span class="dv">16</span>), hash.to_i(<span class="dv">16</span>), <span class="dv">123456789</span>) <span class="co"># using a fixed nonce for testing (unsafe)</span></span>
<span></span>
<span><span class="co"># Use the low s value (BIP 62: Dealing with malleability)</span></span>
<span><span class="kw">if</span> (signature[<span class="st">:s</span>] &gt; <span class="dt">$n</span> / <span class="dv">2</span>)</span>
<span>  signature[<span class="st">:s</span>] = <span class="dt">$n</span> - signature[<span class="st">:s</span>]</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># Encode the signature in to DER format (slightly awkward format used for signatures in bitcoin transactions)</span></span>
<span>r = signature[<span class="st">:r</span>].to_s(<span class="dv">16</span>).rjust(<span class="dv">64</span>, <span class="st">&quot;0&quot;</span>)  <span class="co"># convert r to hexadecimal</span></span>
<span>s = signature[<span class="st">:s</span>].to_s(<span class="dv">16</span>).rjust(<span class="dv">64</span>, <span class="st">&quot;0&quot;</span>)  <span class="co"># convert s to hexadecimal</span></span>
<span>r = <span class="st">&quot;00&quot;</span> + r <span class="kw">if</span> (r[<span class="dv">0</span>, <span class="dv">2</span>].to_i(<span class="dv">16</span>) &gt;= <span class="bn">0x80</span>) <span class="co"># prepend 00 if first byte is 0x80 or above (DER quirk)</span></span>
<span>s = <span class="st">&quot;00&quot;</span> + r <span class="kw">if</span> (s[<span class="dv">0</span>, <span class="dv">2</span>].to_i(<span class="dv">16</span>) &gt;= <span class="bn">0x80</span>) <span class="co"># prepend 00 if first byte is 0x80 or above (DER quirk)</span></span>
<span>der = <span class="st">&quot;&quot;</span>                                   <span class="co"># string for holding our der encoding</span></span>
<span>r_len = (r.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>) <span class="co"># get length of r (in bytes)</span></span>
<span></span>
<span>s_len = (s.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>) <span class="co"># get length of s (in bytes)</span></span>
<span>der &lt;&lt; <span class="st">&quot;02&quot;</span> &lt;&lt; r_len &lt;&lt; r &lt;&lt; <span class="st">&quot;02&quot;</span> &lt;&lt; s_len &lt;&lt; s   <span class="co"># Add to DER encoding (0x20 byte indicates an integer type in DER)</span></span>
<span>der_len = (der.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>).rjust(<span class="dv">2</span>, <span class="st">&quot;0&quot;</span>) <span class="co"># get length of DER data (in bytes)</span></span>
<span>der = <span class="st">&quot;30&quot;</span> + der_len + der <span class="co"># Final DER encoding (0x30 byte incatetes compound object type)</span></span>
<span></span>
<span><span class="co"># Append sighashtype to the signature (required) (01 = ALL)</span></span>
<span>der = der + <span class="st">&quot;01&quot;</span> <span class="co"># without it you get &quot;mandatory-script-verify-flag-failed (Non-canonical DER signature) (code 16)&quot;</span></span>
<span></span>
<span><span class="co"># Contruct full unlocking script (P2PKH scripts need original public key the bitcoins were locked to): &lt;size&gt; {signature} &lt;size&gt; {public_key}</span></span>
<span>scriptsig = (der.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>) + der + (public_key.length / <span class="dv">2</span>).to_s(<span class="dv">16</span>) + public_key</span>
<span></span>
<span><span class="co"># Put the full scriptsig in to the original transaction data</span></span>
<span>transaction = tx(scriptsig)</span>
<span></span>
<span><span class="co"># Show the signed transaction</span></span>
<span>puts transaction <span class="co">#=&gt; 0100000001b7994a0db2f373a29227e1d90da883c6ce1cb0dd2d6812e4558041ebbbcfa54b000000006a473044022008f4f37e2d8f74e18c1b8fde2374d5f28402fb8ab7fd1cc5b786aa40851a70cb02201f40afd1627798ee8529095ca4b205498032315240ac322c9d8ff0f205a93a580121024aeaf55040fa16de37303d13ca1dde85f4ca9baa36e2963a27a1c0c1165fe2b1ffffffff01983a0000000000001976a914b3e2819b6262e0b1f19fc7229d75677f347c91ac88ac00000000</span></span>
<span></span>
<span><span class="co"># Send the transaction in to the bitcoin network</span></span>
<span><span class="co"># $ bitcoin-cli sendrawtransaction [raw transaction data]</span></span></code></pre></div>
<p>It can be quite tricky preparing the data for signing, so it may take a few attempts to get it right. The DER encoding looks especially complicated, but ultimately it’s just the <code>r</code> and <code>s</code> values of the signature with a few bytes thrown in between to indicate the length of data.</p>
<h2>Summary</h2>
<p>The best way to get the hang of ECDSA is to try coding it yourself.</p>
<p>The hardest part is not usually the elliptic curve mathematics, but preparing and formatting the signatures for use inside bitcoin transactions. Furthermore, not all programming languages make it easy to work with big numbers, so you may need to use special functions to perform the elliptic curve operations.</p>
<p>Other than that, the code is not as difficult as you may have initially thought.</p>
<p>Of course, I wouldn’t recommend using this code in your most recent mission-critical system, but it should help you get started with creating your own public keys and signing your own transactions in Bitcoin.</p>
<p>Have fun.</p>
<h3>Links</h3>
<p><strong>References</strong></p>
<ul>
<li>NIST.FIPS.186-4.pdf - Official <em>Digital Signature Standard</em> by <abbr title="National Institute for Standards and Technology">NIST</abbr>. Contains outlines for DSA, RSA, and ECDSA.</li>
<li>sec2-v2.pdf - List of recommended curves for use in elliptic curve cryptography from <abbr title="Standards for Efficient Cryptography Group">SECG</abbr>. Contains parameters for the <code>secp256k1</code> curve used in Bitcoin.</li>
</ul>
<p><strong>Visualisations</strong></p>
<ul>
<li>Elliptic Curve Plotter - A small but cool program that allows you to play with simple elliptic curve operations. It’s what I used to help create the diagrams on this page.</li>
<li>Sage Math - A big mathematical library that comes with elliptic curve plotting functions. I used it to show the plots of elliptic curves over real numbers and over finite fields.</li>
<li>Interactive Elliptic Curve Operations - A cool web tool created by Andrea Corbellini that allows you to visualise elliptic curve addition and double operations over both real numbers and a finite field.</li>
</ul>
<p><strong>Explanations</strong></p>
<ul>
<li>Elliptic Curve Cryptography: A Gentle Introduction - An excellent four-part introduction to Elliptic Curve Cryptography by Andrea Corbellini. A good place to start.</li>
<li>Introducing Elliptic Curves - Introduction to elliptic curves by someone who has a deep understanding of why they are used in cryptography.</li>
<li>An Introduction to Elliptic Curve Cryptography - Another introduction to ECC. Shorter than the two guides above, but I found it helpful.</li>
<li>How The ECDSA Algorithm Works - Concise explanation of ECDSA specifically.</li>
</ul>
<p><strong>Code</strong></p>
<p>Here are some implementations of ECDSA in different programming languages that I found helpful:</p>
<ul>
<li>Python: https://github.com/wobine/blackboard101/blob/master/EllipticCurvesPart5-TheMagic-SigningAndVerifying.py</li>
<li>Python: https://github.com/andreacorbellini/ecc/blob/master/scripts/ecdsa.py</li>
<li>Ruby: https://github.com/DavidEGrayson/ruby_ecdsa</li>
<li>PHP: https://github.com/BitcoinPHP/BitcoinECDSA.php </li>
</ul>
<p><strong>Other</strong></p>
<ul>
<li>Recovering private key from Secp256k1 signatures - Succinct mathematical explanation by Thomas Pornin on how to recover a private key if someone has has used the same random point for their signatures more than once.</li>
<li>Bitcoin’s Signature Types - SIGHASH - Clear explanations of the different signature hash types available in Bitcoin.</li>
<li>bitcoin.it/wiki/OP_CHECKSIG - How to prepare transaction data for hashing when using the different <code>SIGHASH</code> types.</li>
<li>https://plan99.net/~mike/satoshi-emails/thread3.html - Email from Satoshi to Mike Hearn explaining his/her choice of secp256k1.</li>
</ul>
<blockquote>
<p>I must admit, this project was 2 years of development before release, and I could only spend so much time on each of the many issues. I found guidance on the recommended size for SHA and RSA, but nothing on ECDSA which was relatively new. I took the recommended key size for RSA and converted to equivalent key size for ECDSA, but then increased it so the whole app could be said to be 256-bit security. I didn’t find anything to recommend a curve type so I just… picked one. Hopefully there is enough key size to make up for any deficiency. <br><br> – <em>Satoshi Nakamoto</em></p>
</blockquote>

</div>
</div>
</body>
</html>
