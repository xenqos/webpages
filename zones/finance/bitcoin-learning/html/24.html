<!doctype html>
<html lang="en">
<head>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=1.0'>
  <title>Bitcoin Learning</title>
  <link rel='stylesheet' type='text/css' media='screen' href='/styles/commons.css'>
  <link rel="stylesheet" type="text/css" href="../styles/tipped.css">
  <link rel="stylesheet" type="text/css" href="../styles/jquery-ui.min.css">
  <link rel="stylesheet" type="text/css" href="../styles/tachyons.min.css">
  <link rel="stylesheet" type="text/css" href="../styles/style.css">
  <script type='text/javascript' src='/scripts/commons.js'></script>
</head>
<body>
<div id='idPanel'>
<div id='idTopbar'>
  <div id='idTopbarNavigation'>
    <a href='/'><span class='clNavHome'><span></a>
    <a href='../../index.html'><span class='clNavIndex'><span></a>
    <a href='./23.html'><span class='clNavLeft'><span></a>
    <a href='../index.html'><span class='clNavUp'><span></a>
    <a href='./25.html'><span class='clNavRight'><span></a>
  </div>
</div>

<div id='idContent'>

<h1>24.Target</h1>
<p class="subheading">The number you need to get below to mine a block.</p>

<p><a target='_blank' href='../images/24.target.png'><img class='clImageThumb' src='../images/24.target.png'></a><br><br></p>
<p>The target is used in mining. It is a number that a block hash must be below for the block to be added on to the blockchain.</p>
<p>The target adjusts every 2016 blocks (roughly two weeks) to try and ensure that blocks are mined <strong>once every 10 minutes</strong> on average. It therefore creates a <em>consistent time between blocks</em> and a consistent issuance of new bitcoins in to the network (via the block reward).</p>
<blockquote>
<p>To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they’re generated too fast, the difficulty increases. – Satoshi Nakamoto</p>
</blockquote>
<h4>Current target:</h4>
<div style="text-align:center;">
<div class="overflow-x-auto pv3">
<code class="target">000000000000000000077ce20000000000000000000000000000000000000000</code>
</div>
<p>
<small class="grey">Block 772,438</small>
</p>
</div>
<p class="note text" style="margin-top:48px">
The target is in hexadecimal, but it’s still a number.
</p>
<h2>1. When does the target adjust?</h2>
<p>The target adjusts on <strong>every 2016th block</strong>. This is roughly <em>every two weeks</em> (because there are 20,160 minutes in a two-week period).</p>
<p>Here are the dates and target values for every target adjustment in Bitcoin’s history:</p>
<h3>
Bitcoin Target History
</h3>

<h2>2. How is the target calculated?</h2>
<p>The target for the first block was set at:</p>
<div style="text-align:center; margin-top:48px;">
<div class="overflow-x-auto pv3">
<code class="target">00000000ffff0000000000000000000000000000000000000000000000000000</code>
</div>
<p>
<small class="grey">Block 0</small>
</p>
</div>
<p class="note text">
This initial (and maximum) target value is hard-coded in to the source code of every bitcoin node.<sup>1</sup> It was probably best-guess by Satoshi at what be a good starting point for a difficult-enough target that would result in a 10-minute interval between new blocks.
</p>
<p><a target='_blank' href='../images/24.initial-target.png'><img class='clImageThumb' src='../images/24.initial-target.png'></a><br><br></p>
<p>After every 2016 blocks, each node will look at the time between the last 2016 blocks and work out if they were being mined faster or slower than 10 minutes on average.</p>
<p><a target='_blank' href='../images/24.target-period.png'><img class='clImageThumb' src='../images/24.target-period.png'></a><br><br></p>
<p class="note text">
Each block contains a timestamp in its block header. This timestamp is in Unix time, which is the number of seconds since 01 January 1970.
</p>
<p>If blocks during this period were being mined <em>faster</em> than every 10 minutes, the target will <em>adjust downwards</em> to make it <em>more difficult</em> to get below the target for the next period of blocks.</p>
<p><a target='_blank' href='../images/24.target-adjust-down.png'><img class='clImageThumb' src='../images/24.target-adjust-down.png'></a><br><br></p>
<p>Conversely, if blocks were being mined <em>slower</em> than every 10 minutes, the target will <em>adjust upwards</em> to make is <em>easier</em> to get below the target for the next period of blocks.</p>
<p><a target='_blank' href='../images/24.target-adjust-up.png'><img class='clImageThumb' src='../images/24.target-adjust-up.png'></a><br><br></p>
<p>As a result, each node regularly recalculates the target to enforce a 10-minute interval between new blocks, even as miners join and leave the network over time.</p>

<h3>What causes blocks to be mined faster or slower than every 10 minutes?</h3>
<p>Well, first of all, mining is unpredictable, so you never know when a miner is going to find the next block with a block hash below the current target.</p>
<p>Secondly (and most importantly), miners can join and leave the network at any time, which affects the likelihood of new blocks being mined within 10-minute periods. The more miners there are on the network, the more hashing there is taking place, and the more likely it is a new block will be mined in under 10 minutes.</p>
<h2>3. Do all nodes share the same target?</h2>
<p>Each node on the network operates independently, so there is no “single target value” being sent around the network.</p>
<p>However, because <em>all nodes adopt the longest chain of blocks</em> as their blockchain, they will each <em>end up calculating the same target</em> as everyone else, so <strong>effectively all nodes end up sharing the same current target</strong>.</p>
<p>For example, when you run bitcoin for the first time, your node will perform the initial block download and calculate the targets as it goes. And because you’re receiving the same blocks as everyone else, you will end up calculating the same current target too.</p>
<p><a target='_blank' href='../images/24.target-independent-calculation.png'><img class='clImageThumb' src='../images/24.target-independent-calculation.png'></a><br><br></p>
<p>Furthermore, all nodes continually share the same view of the blockchain (as they will always adopt the longest available chain of blocks). Therefore, nodes will also continually calculate the same target value as each new block is mined.</p>
<p><a target='_blank' href='../images/24.target-independent-calculation-agree.png'><img class='clImageThumb' src='../images/24.target-independent-calculation-agree.png'></a><br><br></p>
<p>As a result, despite the fact nodes calculate the target independently, they each share the same blockchain and calculate the same target value as each other.</p>
<blockquote>
<p>Everyone does the same calculation with the same chain data, so they all get the same result at the same link in the chain. – Satoshi Nakamoto</p>
</blockquote>
<h2>4. Why does bitcoin use a target?</h2>
<p>The target <strong>regulates the speed at which new blocks are added on to the blockchain</strong>.</p>
<p>This has two benefits:</p>
<h3>i. It gives blocks time to propagate across the network.</h3>
<p>It’s ideal to have miners working on extending the <em>same chain of blocks</em> as much as possible. For this to work, we need to <em>allow time for new blocks to propagate across the network</em> before the next block gets mined.</p>
<p><a target='_blank' href='../images/24.block-propagation.png'><img class='clImageThumb' src='../images/24.block-propagation.png'></a><br><br></p>
<p>If blocks are being mined faster than they can be broadcast across the network, it will result in miners regularly building competing chains. Only one of these will become the longest, so some miners will end up wasting energy working to build on top of a competing chain only for it to be left behind due to a chain reorganisation.</p>
<p><a target='_blank' href='../images/24.block-propagation-mining-split.png'><img class='clImageThumb' src='../images/24.block-propagation-mining-split.png'></a><br><br></p>
<p>Therefore, this time delay between blocks allows them to propagate the network so that more miners can adopt the longest available chain, which concentrates the network’s mining power on extending the same chain of blocks.</p>
<p><a target='_blank' href='../images/24.block-propagation-mining-focused.png'><img class='clImageThumb' src='../images/24.block-propagation-mining-focused.png'></a><br><br></p>
<blockquote>
<p>If broadcasts turn out to be slower in practice than expected, the target time between blocks may have to be increased to avoid wasting resources. We want blocks to usually propagate in much less time than it takes to generate them, otherwise nodes would spend too much time working on obsolete blocks. – Satoshi Nakamoto</p>
</blockquote>
<h3>ii. A consistent issuance of new bitcoins.</h3>
<p>Bitcoin is a <em>currency</em>, so having a fixed rate of new bitcoins introduced in to the system provides stability.</p>

<a target='_blank' href='../images/24.block-reward-constant-rate.png'><img class='clImageThumb' src='../images/24.block-reward-constant-rate.png'></a><br><br>
<p class='clFigcaption'>Thanks to the target you can be confident that new bitcoins will be minted at a predictable rate for as long as the network is running.</p>


<blockquote>
<p>Coins have to get initially distributed somehow, and a constant rate seems like the best formula. – Satoshi Nakamoto</p>
</blockquote>
<h2>5. Why 10 minutes between blocks?</h2>
<p>I don’t think anyone knows why <strong>10 minutes</strong> exactly was chosen, except for Satoshi.</p>
<p>My guess is that it seems like a long-enough time to allow blocks to propagate around the network (to minimize chain reorganisations), and short-enough so that you do not have to wait too long for a new transaction to get mined on to the blockchain. And <strong>10</strong> is a nice round number.</p>
<h2>6. Where can you find the target?</h2>
<p>The target gets stored in the bits field in the block header of every block.</p>

<a target='_blank' href='../images/24.block-header-bits.png'><img class='clImageThumb' src='../images/24.block-header-bits.png'></a><br><br>
<p class='clFigcaption'>The target is stored in a compact format to save space.</p>


<h2>Commands</h2>
<div class="note command">
<h4>
<code>bitcoin-cli getblocktemplate</code>
</h4>
<p>The is the simplest way to get the current target. When you request a block template for mining it also returns the current target:</p>
<pre><code>$ bitcoin-cli getblocktemplate &#39;{&quot;rules&quot;: [&quot;segwit&quot;]}&#39; | grep target
  &quot;target&quot;: &quot;000000000000000000077ce20000000000000000000000000000000000000000&quot;,</code></pre>
</div>
<div class="note command">
<h4>
<code>bitcoin-cli getdifficulty</code>
</h4>
<p>Similarly you can just ask for the current difficulty, which you can then convert to the target:</p>
<pre><code>$ bitcoin-cli getdifficulty
39350942467773</code></pre>
</div>
<div class="note command">
<h4>
<code>bitcoin-cli getblockheader</code>
</h4>
<p>Alternatively, as mentioned, the target at the time of mining is stored in every block header in the bits format (which you can convert to a full target value):</p>
<pre><code>$ bitcoin-cli getblockheader 000000000000000002e9533a4fe03bb251b3fdb30ffaa384aad133b7fae594cf
{
  &quot;hash&quot;: &quot;000000000000000002e9533a4fe03bb251b3fdb30ffaa384aad133b7fae594cf&quot;,
  &quot;confirmations&quot;: 207763,
  &quot;height&quot;: 401184,
  &quot;version&quot;: 4,
  &quot;versionHex&quot;: &quot;00000004&quot;,
  &quot;merkleroot&quot;: &quot;b4afa0502a55fdfa4a5cda6ea2bc546ba527d276ea9c7e848b8cd478cd9b6607&quot;,
  &quot;time&quot;: 1457133956,
  &quot;mediantime&quot;: 1457132303,
  &quot;nonce&quot;: 3778923481,
  &quot;bits&quot;: &quot;1806f0a8&quot;,
  &quot;difficulty&quot;: 158427203767.3917,
  &quot;chainwork&quot;: &quot;00000000000000000000000000000000000000000012da32364c8f47d519604d&quot;,
  &quot;nTx&quot;: 845,
  &quot;previousblockhash&quot;: &quot;000000000000000003c4a4d9c62b3a7f4893afe14eef8a6a377229d23ad4b1ea&quot;,
  &quot;nextblockhash&quot;: &quot;00000000000000000037ab74c8db9b7a9d7de039210d8eafaeb44ba35adfb624&quot;
}
</code></pre>
<p class="note tip">
<strong>Tip:</strong> You can get the target for the top block in the chain with:<br>
<div class='clOverflow'>
<code>$ bitcoin-cli getblockheader $(bitcoin-cli getblockhash $(bitcoin-cli getblockcount))</code>
</div>
</p>
<p class="note text">
<strong>Note:</strong> This will give you the target for <em>that block</em>, and not necessarily the current target being used for the next block.
</p>
</div>
<h2>Code</h2>
<p>Here’s some example Ruby code for calculating new target values. This code works out the new target for block 403,200, using the timestamps from blocks 401,184 and 403,199.</p>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="co"># 403,200 - NEW TARGET</span></span>
<span><span class="co"># 403,199              | last block</span></span>
<span><span class="co">#                      |</span></span>
<span><span class="co">#                      |</span></span>
<span><span class="co">#                      |</span></span>
<span><span class="co"># 401,184 - NEW TARGET | first block (target = 0x000000000000000006f0a8000000000000000000000000000000000000000000)</span></span>
<span></span>
<span><span class="co"># 1. Get the timestamps for the first and last block in the target adjustment period</span></span>
<span>first = <span class="dv">1457133956</span> <span class="co"># block 401,184</span></span>
<span>last  = <span class="dv">1458291885</span> <span class="co"># block 403,199</span></span>
<span></span>
<span><span class="co"># 2. Work out the ratio of the actual time against the expected time</span></span>
<span>actual = last - first     <span class="co"># 1157929 (number of seconds between first and last block)</span></span>
<span>expected = <span class="dv">2016</span> * <span class="dv">10</span> * <span class="dv">60</span> <span class="co"># 1209600 (number of seconds expected between 2016 blocks)</span></span>
<span>ratio = actual.to_f / expected.to_f</span>
<span></span>
<span><span class="co"># 3. Limit the adjustment by a factor of 4 (to prevent massive changes from one target to the next)</span></span>
<span>ratio = <span class="fl">0.25</span> <span class="kw">if</span> ratio &lt; <span class="fl">0.25</span></span>
<span>ratio = <span class="dv">4</span> <span class="kw">if</span> ratio &gt; <span class="dv">4</span></span>
<span></span>
<span><span class="co"># 4. Multiply the current target by this ratio to get the new target</span></span>
<span>current_target = <span class="bn">0x000000000000000006f0a8000000000000000000000000000000000000000000</span></span>
<span>new_target = (current_target * ratio)</span>
<span></span>
<span><span class="co"># 5. Don&#39;t let the target go above the maximum target</span></span>
<span>max_target = <span class="bn">0x00000000ffff0000000000000000000000000000000000000000000000000000</span></span>
<span>new_target = max_target <span class="kw">if</span> new_target &gt; max_target</span>
<span></span>
<span><span class="co"># 5. Truncate the target, because the official target is the truncated &quot;bits&quot; format stored in the block header</span></span>
<span><span class="co"># This code is a bit rough, because it&#39;s working with strings when I should really be working with actual bytes.</span></span>
<span>new_target = new_target.to_i.to_s(<span class="dv">16</span>) <span class="co"># convert from decimal to hexadecimal</span></span>
<span>new_target = new_target.size % <span class="dv">2</span> != <span class="dv">0</span> ? <span class="ch">&#39;0&#39;</span> + new_target : new_target <span class="co"># make sure it&#39;s an even number of characters (i.e. bytes)</span></span>
<span>truncated = new_target.scan(<span class="ot">/../</span>).each_with_index.map { |byte, i| byte = i &gt;= <span class="dv">3</span> ? <span class="st">&quot;00&quot;</span> : byte }.join <span class="co"># set all bytes apart from first 3 to zeros</span></span>
<span><span class="co"># e.g. 6a4c316c01f354000000000000000000000000000000000 &lt;- full precision</span></span>
<span><span class="co"># e.g. 6a4c3000000000000000000000000000000000000000000 &lt;- official target</span></span>
<span></span>
<span><span class="co"># 6. Display the full target (with leading zeros)</span></span>
<span>target = truncated.rjust(<span class="dv">64</span>, <span class="ch">&#39;0&#39;</span>)</span>
<span>puts target</span>
<span><span class="co"># 000000000000000006a4c3000000000000000000000000000000000000000000</span></span></code></pre></div>
<p class="note tip">
<strong>Tip:</strong> You can get the timestamp for a block with <code>bitcoin-cli getblockheader &lt;hash&gt;</code> (and you can get the block hash for a block at a specific height with <code>bitcoin-cli getblockhash &lt;height&gt;</code>).
</p>
<p class="note text">
<strong>Official Target:</strong> The <em>official</em> target is the truncated target that gets stored in the block header (in the bits field), so it’s not actually the full-precision target that you get after adjusting the previous one.
</p>
<p class="note text">
<strong>Off-by-one:</strong> You may notice that new target is calculated using the time across <strong>2015</strong> blocks (and not across 2016 as you would expect). This is an implementation error in the code that still exists today.
</p>
<p class="note text">
<strong>Factor of 4:</strong> Target adjustments are limited by a factor of 4 to prevent overly-large adjustments from one target to the next.
</p>

</div>
</div>
</body>
</html>
